<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>gRPC客户端详解 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="RPC框架的选择常见的RPC框架主要分为轻重两种。较轻的框架一般只负责通信，如rmi、webservice、restful、Thrift、gRPC等。较重的框架一般包括完整的服务发现、负载均衡策略等等如BAT三家的Dubbo、brpc、Tars之类。 框架选择时个人认为首先要考虑的是框架的历史和项目的活跃程度。一个历史悠久的活跃项目（大概至少可以保证每两到三个月有一次小版本的更新）可以保证各种bu">
<meta property="og:type" content="article">
<meta property="og:title" content="gRPC客户端详解">
<meta property="og:url" content="http://liumenghan.github.io/2019/10/07/grpc-in-depth/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="RPC框架的选择常见的RPC框架主要分为轻重两种。较轻的框架一般只负责通信，如rmi、webservice、restful、Thrift、gRPC等。较重的框架一般包括完整的服务发现、负载均衡策略等等如BAT三家的Dubbo、brpc、Tars之类。 框架选择时个人认为首先要考虑的是框架的历史和项目的活跃程度。一个历史悠久的活跃项目（大概至少可以保证每两到三个月有一次小版本的更新）可以保证各种bu">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://liumenghan.github.io/2019/10/07/grpc-in-depth/starter-genenate-grpc.png">
<meta property="og:image" content="http://liumenghan.github.io/2019/10/07/grpc-in-depth/DnsNameResolver-start.png">
<meta property="og:image" content="http://liumenghan.github.io/2019/10/07/grpc-in-depth/call-handle-resolved-response.png">
<meta property="og:image" content="http://liumenghan.github.io/2019/10/07/grpc-in-depth/defaulLoadBalancingPolicy.png">
<meta property="og:image" content="http://liumenghan.github.io/2019/10/07/grpc-in-depth/start-subchannel.png">
<meta property="og:image" content="http://liumenghan.github.io/2019/10/07/grpc-in-depth/start-call.png">
<meta property="og:image" content="http://liumenghan.github.io/2019/10/07/grpc-in-depth/calling-new-stream.png">
<meta property="og:image" content="http://liumenghan.github.io/2019/10/07/grpc-in-depth/request-on-next.png">
<meta property="og:image" content="http://liumenghan.github.io/2019/10/07/grpc-in-depth/request-on-complete.png">
<meta property="og:image" content="http://liumenghan.github.io/2019/10/07/grpc-in-depth/response-on-next.png">
<meta property="og:image" content="http://liumenghan.github.io/2019/10/07/grpc-in-depth/response-on-complete.png">
<meta property="og:updated_time" content="2019-10-07T12:27:46.715Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="gRPC客户端详解">
<meta name="twitter:description" content="RPC框架的选择常见的RPC框架主要分为轻重两种。较轻的框架一般只负责通信，如rmi、webservice、restful、Thrift、gRPC等。较重的框架一般包括完整的服务发现、负载均衡策略等等如BAT三家的Dubbo、brpc、Tars之类。 框架选择时个人认为首先要考虑的是框架的历史和项目的活跃程度。一个历史悠久的活跃项目（大概至少可以保证每两到三个月有一次小版本的更新）可以保证各种bu">
<meta name="twitter:image" content="http://liumenghan.github.io/2019/10/07/grpc-in-depth/starter-genenate-grpc.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://liumenghan.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-grpc-in-depth" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/10/07/grpc-in-depth/" class="article-date">
  <time datetime="2019-10-07T12:27:46.715Z" itemprop="datePublished">2019-10-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      gRPC客户端详解
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="RPC框架的选择"><a href="#RPC框架的选择" class="headerlink" title="RPC框架的选择"></a>RPC框架的选择</h1><p>常见的RPC框架主要分为轻重两种。较轻的框架一般只负责通信，如rmi、webservice、restful、Thrift、gRPC等。较重的框架一般包括完整的服务发现、负载均衡策略等等如BAT三家的Dubbo、brpc、Tars之类。</p>
<p>框架选择时个人认为首先要考虑的是框架的历史和项目的活跃程度。一个历史悠久的活跃项目（大概至少可以保证每两到三个月有一次小版本的更新）可以保证各种bug早已暴露并修复，让我们可以更专注于我们自己的项目本身，而不是要担心究竟是我们自己的代码有问题还是框架本身就有问题。</p>
<p>重量级RPC框架有一个主要问题就是结构复杂，另外主语言之外的代码质量也不太容易保证。个人认为活跃的社区以及一个活跃的开源管理团队是这些重型RPC框架项目成功的必要前提条件。比如我们项目组试用过腾讯的Tars，C++同学表示没有任何问题，然后JAVA同学表示java版本有许多bug，修复bug的pull request需要两个多月才能得到merge，而官方jar包也将近两年没有更新过了。</p>
<p>轻量级rpc框架中，restful可以被视作标杆。由于restful基于http协议，天然被各种框架支持，而且非常灵活。restful的缺点有两方面，一是过于灵活，缺少根据协议生成服务端和客户端代码的工具，联调往往要花更多的时间；二是大部分序列化基于json或者xml，相对来讲效率不理想。和restful相比，其它很多轻量级框架都有这样或者那样的缺点，有的缺少跨语言支持（rmi），有的既繁琐又缺乏效率优势（webservice）。个人认为其中相对理想的是gRPC和Thrift。</p>
<h2 id="gRPC简介"><a href="#gRPC简介" class="headerlink" title="gRPC简介"></a>gRPC简介</h2><p>Protobuf是一种google推出的非常流行的跨语言序列化/反序列化框架。在Protobuf2中就已经出现了用rpc定义服务的概念，但是一直缺少一种流行的rpc框架支持。当Http2推出之后，google将Http2和protobuf3结合，推出了gRPC。gRPC继承了Protobuf和Http2的优点，包括：</p>
<ul>
<li>序列化反序列化性能好</li>
<li>强类型支持</li>
<li>向前/向后兼容</li>
<li>有代码生成机制，而且可以支持多语言</li>
<li>长连接、多路复用</li>
</ul>
<p>同时gRPC还提供了简单地服务发现和负载均衡功能。虽然这并不是gRPC框架的重点，但是开发者可以非常容易的自己扩展gRPC这些功能，实现自己的策略或应用最新的相关方面技术，而不用像重型RPC框架一样受制于框架本身是否支持。</p>
<h2 id="gRPC与Thrift对比"><a href="#gRPC与Thrift对比" class="headerlink" title="gRPC与Thrift对比"></a>gRPC与Thrift对比</h2><p>Thrift是Facebook推出的一种RPC框架，从性能上来讲远优于gRPC。但是在实际调研时发现有一个很麻烦的问题：Thrift的客户端是<strong>线程不安全</strong>的——这意味着在Spring中无法以单例形式注入到Bean中。解决方案有三种：</p>
<ol>
<li>每次调用创建一个Thrift客户端。这不仅意味着额外的对象创建和垃圾回收开销，而且实际上相当于只使用了短链接，这是一个开发复杂度最低但是从性能上来讲最差的解决方案。</li>
<li>利用Pool，稍微复杂一点的解决方案，但是也非常成熟。但是问题在于一来缺少服务发现和负载均衡恐实现，需要很多额外开发；二来需要创建Pool数量*服务端数量个客户端，内存开销会比较大。</li>
<li>使用异步框架如Netty，可以成功避免创建过多的客户端，但是仍要自己实现服务发现和负载均衡，相对复杂。实际上Facebook有一个基于Netty的Thrift客户端，叫Nifty，但是快四年没更新了。。。</li>
</ol>
<p>相比较而言gRPC就友好多了，本身有简单而且可扩展的服务发现和负载均衡功能，底层基于Netty所以线程安全，在不需要极限压榨性能的情况下是非常好的选择。当然如果需要极限压榨性能Thrift也未必够看。</p>
<h1 id="gRPC入门"><a href="#gRPC入门" class="headerlink" title="gRPC入门"></a>gRPC入门</h1><h2 id="gRPC服务定义"><a href="#gRPC服务定义" class="headerlink" title="gRPC服务定义"></a>gRPC服务定义</h2><p>gRPC中有一个特殊的关键字<strong>stream</strong>，表示可以以流式输入或输出多个protobuf对象。注意只有异步非阻塞的客户端支持以stream形式输入，同步阻塞客户端不支持以stream形式输入。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">syntax = &quot;proto3&quot;;  //gRPC必须使用proto3</span><br><span class="line"></span><br><span class="line">option java_multiple_files = true;</span><br><span class="line">option java_package = &quot;cn.lmh.examples.grpc.proto&quot;;</span><br><span class="line"></span><br><span class="line">service RouteGuide &#123;</span><br><span class="line">	// 输入一个坐标，返回坐标和时间(1:1)</span><br><span class="line">	rpc getPoint(Point) returns (LocationNote) &#123;&#125;</span><br><span class="line">	// 输入一个矩形，以stream形式返回一系列点(1:n)</span><br><span class="line">	rpc listPoints(Rectangle) returns (stream Point) &#123;&#125;</span><br><span class="line">	// 以stream形式输入一系列点，返回点的数量和总共花费的时间(m:1)</span><br><span class="line">	rpc recordRoute(stream Point) returns (RouteSummary) &#123;&#125;</span><br><span class="line">	// 以stream形式输入一系列点，以stream形式返回已输入点的数量和总共花费的时间(m:n)</span><br><span class="line">	rpc getPointStream(stream Point) returns (stream RouteSummary) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message Point &#123;</span><br><span class="line">	int32 latitude = 1;</span><br><span class="line">	int32 longitude = 2;</span><br><span class="line">&#125;</span><br><span class="line">message Rectangle &#123;</span><br><span class="line">	Point lo = 1;</span><br><span class="line">	Point hi = 2;</span><br><span class="line">&#125;</span><br><span class="line">message LocationNote &#123;</span><br><span class="line">	Point location = 1;</span><br><span class="line">	int64 timestamp = 2;</span><br><span class="line">&#125;</span><br><span class="line">message RouteSummary &#123;</span><br><span class="line">	int32 point_count = 1;</span><br><span class="line">	int64 elapsed_time = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="依赖和代码生成"><a href="#依赖和代码生成" class="headerlink" title="依赖和代码生成"></a>依赖和代码生成</h2><p>由于protoc的gRPC插件需要自己编译，而且存在环境问题。推荐使用gradle或者maven的protobuf插件。入门示例项目使用了gradle，根目录build.gradle配置如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">	id &apos;java&apos;</span><br><span class="line">	id &apos;idea&apos;</span><br><span class="line">	id &apos;wrapper&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ext &#123;</span><br><span class="line">	groupId = &apos;cn.lmh.leviathan&apos;</span><br><span class="line">	proto = [</span><br><span class="line">		version : &quot;3.9.0&quot;,</span><br><span class="line">		&quot;grpc&quot; :[</span><br><span class="line">			version : &quot;1.23.0&quot;</span><br><span class="line">		]</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">allprojects&#123;</span><br><span class="line">	apply plugin: &apos;java&apos;</span><br><span class="line">	apply plugin: &apos;idea&apos;</span><br><span class="line"></span><br><span class="line">	sourceCompatibility=JavaVersion.VERSION_1_8</span><br><span class="line">	targetCompatibility=JavaVersion.VERSION_1_8</span><br><span class="line"></span><br><span class="line">	project.group = &apos;cn.lmh.examples&apos;</span><br><span class="line"></span><br><span class="line">	compileJava.options.encoding = &apos;UTF-8&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">subprojects&#123;</span><br><span class="line">	repositories &#123;</span><br><span class="line">		mavenCentral()</span><br><span class="line">		mavenLocal();</span><br><span class="line">	&#125;;</span><br><span class="line">	configurations &#123;</span><br><span class="line">		compile</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dependencies &#123;</span><br><span class="line">		compile &quot;io.grpc:grpc-netty-shaded:$&#123;proto.grpc.version&#125;&quot;</span><br><span class="line">		compile &quot;io.grpc:grpc-protobuf:$&#123;proto.grpc.version&#125;&quot;</span><br><span class="line">		compile &quot;io.grpc:grpc-stub:$&#123;proto.grpc.version&#125;&quot;</span><br><span class="line"></span><br><span class="line">		testCompile group: &apos;junit&apos;, name: &apos;junit&apos;, version: &apos;4.12&apos;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子项目build.gradle如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">plugins&#123;</span><br><span class="line">	id &apos;com.google.protobuf&apos; version &apos;0.8.10&apos;	//引入protobuf插件</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sourceSets&#123;</span><br><span class="line">	main&#123;</span><br><span class="line">		proto &#123;</span><br><span class="line">			srcDir &apos;src/main/proto&apos;	//指定.proto文件所在的位置</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protobuf &#123;</span><br><span class="line">	generatedFilesBaseDir = &quot;$projectDir/src&quot;	//生成文件的根目录</span><br><span class="line"></span><br><span class="line">	protoc &#123;</span><br><span class="line">		artifact = &quot;com.google.protobuf:protoc:$&#123;proto.version&#125;&quot;	//protoc的版本</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	plugins &#123;</span><br><span class="line">		grpc &#123;</span><br><span class="line">			artifact = &quot;io.grpc:protoc-gen-grpc-java:$&#123;proto.grpc.version&#125;&quot;	//gRPC的版本</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	generateProtoTasks &#123;</span><br><span class="line">		all()*.plugins &#123;</span><br><span class="line">			grpc &#123;</span><br><span class="line">				outputSubDir = &quot;java&quot;	//grpc生成文件的子目录</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们的入门子项目名称叫做starter，配置好build.gradle之后，执行gradlew :starter:generateProto就可以在src/main/java下生成对应的文件：</p>
<p><img src="//liumenghan.github.io/2019/10/07/grpc-in-depth/starter-genenate-grpc.png" alt="gRPC生成的目录结构"></p>
<h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><p>无论客户端以异步非阻塞还是同步阻塞形式调用，gRPC服务端的Response都是异步形式。对于异步的Request或者Response，都需要实现gRPC的<code>io.grpc.stub.StreamObserver</code>接口。<code>io.grpc.stub.StreamObserver</code>接口有三个方法：</p>
<ul>
<li><code>onNext</code>:表示接收/发送一个对象</li>
<li><code>onError</code>:处理异常</li>
<li><code>onCompleted</code>:表示Request或Response结束</li>
</ul>
<p>当Request发送到服务端端时，会异步调用requestObserver的onNext方法，直到结束时调用requestObserver的onCompleted方法；服务端调用responseObserver的onNext把Response返回给客户端，直到调用responseObserver的onCompleted方法通知客户端Response结束。服务端代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line">public class RouteGuideServer &#123;</span><br><span class="line">	private final int port;</span><br><span class="line">	private final Server server;</span><br><span class="line"></span><br><span class="line">	public RouteGuideServer(int port) throws IOException &#123;</span><br><span class="line">		this.port = port;</span><br><span class="line">		server = ServerBuilder.forPort(port).addService(new RouteGuideService())</span><br><span class="line">				.build();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Start server.</span><br><span class="line">	 */</span><br><span class="line">	public void start() throws IOException &#123;</span><br><span class="line">		server.start();</span><br><span class="line">		System.out.println(&quot;Server started, listening on &quot; + port);</span><br><span class="line">		Runtime.getRuntime().addShutdownHook(new Thread() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				RouteGuideServer.this.stop();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Stop server</span><br><span class="line">	 */</span><br><span class="line">	public void stop() &#123;</span><br><span class="line">		if (server != null) &#123;</span><br><span class="line">			server.shutdown();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Await termination on the main thread since the grpc library uses daemon threads.</span><br><span class="line">	 */</span><br><span class="line">	private void blockUntilShutdown() throws InterruptedException &#123;</span><br><span class="line">		if (server != null) &#123;</span><br><span class="line">			server.awaitTermination();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) throws Exception &#123;</span><br><span class="line">		RouteGuideServer server = new RouteGuideServer(8980);</span><br><span class="line">		server.start();</span><br><span class="line">		server.blockUntilShutdown();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private static class RouteGuideService extends RouteGuideGrpc.RouteGuideImplBase &#123;</span><br><span class="line">		@Override</span><br><span class="line">		public void getPoint(Point request, StreamObserver&lt;LocationNote&gt; responseObserver) &#123;</span><br><span class="line">			LocationNote value = LocationNote</span><br><span class="line">				.newBuilder()</span><br><span class="line">				.setLocation(request)</span><br><span class="line">				.setTimestamp(System.nanoTime())</span><br><span class="line">				.build();</span><br><span class="line">			responseObserver.onNext(value);</span><br><span class="line">			responseObserver.onCompleted();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		@Override</span><br><span class="line">		public void listPoints(Rectangle request, StreamObserver&lt;Point&gt; responseObserver) &#123;</span><br><span class="line">			int left = Math.min(request.getLo().getLongitude(), request.getHi().getLongitude());</span><br><span class="line">			int right = Math.max(request.getLo().getLongitude(), request.getHi().getLongitude());</span><br><span class="line">			int top = Math.max(request.getLo().getLatitude(), request.getHi().getLatitude());</span><br><span class="line">			int bottom = Math.max(request.getLo().getLatitude(), request.getHi().getLatitude());</span><br><span class="line">			for (int x = left; x &lt;= right; x++) &#123;</span><br><span class="line">				for (int y = top; y &gt;= bottom; y--) &#123;</span><br><span class="line">					Point point = Point.newBuilder().setLongitude(x).setLatitude(y).build();</span><br><span class="line">					responseObserver.onNext(point);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			responseObserver.onCompleted();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		@Override</span><br><span class="line">		public StreamObserver&lt;Point&gt; recordRoute(StreamObserver&lt;RouteSummary&gt; responseObserver) &#123;</span><br><span class="line">			return new StreamObserver&lt;Point&gt;() &#123; //返回的是requestObserver</span><br><span class="line">				AtomicInteger pointCount = new AtomicInteger(0);</span><br><span class="line">				final long startTime = System.nanoTime();</span><br><span class="line"></span><br><span class="line">				@Override</span><br><span class="line">				public void onNext(Point value) &#123;</span><br><span class="line">					int count = pointCount.incrementAndGet();</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				@Override</span><br><span class="line">				public void onError(Throwable t) &#123;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				@Override</span><br><span class="line">				public void onCompleted() &#123;</span><br><span class="line">					RouteSummary result = RouteSummary.newBuilder().setElapsedTime(System.nanoTime() - startTime).setPointCount(pointCount.get()).build();</span><br><span class="line">					responseObserver.onNext(result);</span><br><span class="line">					responseObserver.onCompleted();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		@Override</span><br><span class="line">		public StreamObserver&lt;Point&gt; getPointStream(StreamObserver&lt;RouteSummary&gt; responseObserver) &#123;</span><br><span class="line">			return new StreamObserver&lt;Point&gt;() &#123; //返回的是requestObserver</span><br><span class="line">				AtomicInteger pointCount = new AtomicInteger(0);</span><br><span class="line">				final long startTime = System.nanoTime();</span><br><span class="line"></span><br><span class="line">				@Override</span><br><span class="line">				public void onNext(Point value) &#123;</span><br><span class="line">					int count = pointCount.incrementAndGet();</span><br><span class="line">					RouteSummary result = RouteSummary.newBuilder().setElapsedTime(System.nanoTime() - startTime).setPointCount(count).build();</span><br><span class="line">					responseObserver.onNext(result);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				@Override</span><br><span class="line">				public void onError(Throwable t) &#123;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				@Override</span><br><span class="line">				public void onCompleted() &#123;</span><br><span class="line">					responseObserver.onCompleted();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>gRPC的客户端有同步阻塞客户端（blockingStub)和异步非阻塞客户端(Stub）两种。同步客户端使用比较方便，但是性能较低，而且不支持stream形式的Request;异步客户端性能较高，支持stream形式的Request，但是如果想要以同步方式调用需要额外封装。本文将主要以异步为例。</p>
<h3 id="异步转同步"><a href="#异步转同步" class="headerlink" title="异步转同步"></a>异步转同步</h3><p>由于gRPC的异步客户端性能较高且功能更完整，所以一般都会采用异步客户端。异步客户端接收到的Response也是以<code>io.grpc.stub.StreamObserver</code>形式。由于客户端的调用可能是在异步进程中但更可能是在同步进程中，所以就存在一个如何把gRPC异步Response转为同步Response的问题。</p>
<p>一个比较常见的思路是写一个<code>io.grpc.stub.StreamObserver</code>实现，里面有一个内置变量保存异步Response的结果，再添加一个阻塞式的<code>get()</code>方法，直到Response结束才把所有结果返回。要知道Response是否结束，需要添加一个<code>Boolean</code>或者<code>AtomicBoolean</code>变量，初始化为<code>false</code>，调用<code>responseObserver.onCompleted()</code>方法时设置为<code>true</code>，这样就可以通过这个变量判断Response是否结束。</p>
<p>阻塞<code>get()</code>方法最常见的思路是<code>get()</code>写一个<code>while</code>循环，直到变量值改为<code>true</code>才退出循环并返回结果。这种方式的优点是简单直接，任何语言都可以简单实现，缺点是由于使用循环可能CPU占用较高。而对于java这种多线程比较完善的语言，另一个比较好思路是Response结束前将线程挂起，当调用<code>responseObserver.onCompleted()</code>方法再唤醒线程。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class CallableStreamObserver&lt;T&gt; implements StreamObserver&lt;T&gt; &#123;</span><br><span class="line">	List&lt;T&gt; values = new ArrayList&lt;T&gt;();</span><br><span class="line">	boolean isCompleted = false;</span><br><span class="line">	Throwable t = null;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void onNext(T value) &#123;</span><br><span class="line">		this.values.add(value);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void onError(Throwable t) &#123;</span><br><span class="line">		this.isCompleted = true;</span><br><span class="line">		notifyAll();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public synchronized void onCompleted() &#123;</span><br><span class="line">		this.isCompleted = true;</span><br><span class="line">		notifyAll();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public List&lt;T&gt; get() throws Throwable &#123;</span><br><span class="line">		if (!this.isCompleted) &#123;</span><br><span class="line">			synchronized (this) &#123;</span><br><span class="line">				this.wait(60 * 1000);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (null != t) &#123;</span><br><span class="line">			throw this.t;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			return this.values;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="客户端代码"><a href="#客户端代码" class="headerlink" title="客户端代码"></a>客户端代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">public class RouteGuideClient &#123;</span><br><span class="line"></span><br><span class="line">    private final ManagedChannel channel;</span><br><span class="line">    private final RouteGuideGrpc.RouteGuideBlockingStub blockingStub;</span><br><span class="line">    private final RouteGuideGrpc.RouteGuideStub asyncStub;</span><br><span class="line"></span><br><span class="line">    public RouteGuideClient(String host, int port) &#123;</span><br><span class="line">        String target = &quot;dns:///&quot; + host + &quot;:&quot; + port;</span><br><span class="line">        ManagedChannelBuilder&lt;?&gt; channelBuilder = ManagedChannelBuilder</span><br><span class="line">                .forTarget(target)</span><br><span class="line">                .usePlaintext();</span><br><span class="line">        channel = channelBuilder.build();</span><br><span class="line">        blockingStub = RouteGuideGrpc.newBlockingStub(channel);</span><br><span class="line">        asyncStub = RouteGuideGrpc.newStub(channel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void shutdown() throws InterruptedException &#123;</span><br><span class="line">        channel.shutdown().awaitTermination(5, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public LocationNote getPoint(int lo, int lt, boolean blocking) throws Throwable &#123;</span><br><span class="line">        Point point = Point.newBuilder().setLongitude(lo).setLatitude(lt).build();</span><br><span class="line">        if(blocking) &#123;</span><br><span class="line">            return blockingStub.getPoint(point);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            CallableStreamObserver&lt;LocationNote&gt; responseObserver = new CallableStreamObserver&lt;LocationNote&gt;();</span><br><span class="line">            asyncStub.getPoint(point, responseObserver);</span><br><span class="line">            return responseObserver.get().get(0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Iterator&lt;Point&gt; listPoints(int left, int top, int right, int bottom, boolean blocking) throws Throwable &#123;</span><br><span class="line">        Point hi = Point.newBuilder().setLongitude(left).setLatitude(top).build();</span><br><span class="line">        Point lo = Point.newBuilder().setLongitude(right).setLatitude(bottom).build();</span><br><span class="line">        Rectangle rec = Rectangle.newBuilder().setHi(hi).setLo(lo).build();</span><br><span class="line">        if(blocking)&#123;</span><br><span class="line">            return blockingStub.listPoints(rec);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            CallableStreamObserver&lt;Point&gt; responseObserver = new CallableStreamObserver&lt;Point&gt;();</span><br><span class="line">            asyncStub.listPoints(rec, responseObserver);</span><br><span class="line">            return responseObserver.get().iterator();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public RouteSummary recordRoute(Collection&lt;Point&gt; points) throws Throwable &#123;</span><br><span class="line">        CallableStreamObserver&lt;RouteSummary&gt; responseObserver = new CallableStreamObserver&lt;RouteSummary&gt;();</span><br><span class="line">        StreamObserver&lt;Point&gt; requestObserver = asyncStub.recordRoute(responseObserver);</span><br><span class="line">        points.stream().parallel().forEach(p -&gt; requestObserver.onNext(p));</span><br><span class="line">        requestObserver.onCompleted();</span><br><span class="line">        return responseObserver.get().get(0);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List&lt;RouteSummary&gt; getPointStream(Collection&lt;Point&gt; points) throws Throwable &#123;</span><br><span class="line">        CallableStreamObserver&lt;RouteSummary&gt; responseObserver = new CallableStreamObserver&lt;RouteSummary&gt;();</span><br><span class="line">        StreamObserver&lt;Point&gt; requestObserver = asyncStub.getPointStream(responseObserver);</span><br><span class="line">        points.stream().parallel().forEach(p -&gt; requestObserver.onNext(p));</span><br><span class="line">        requestObserver.onCompleted();</span><br><span class="line">        return responseObserver.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="gRPC客户端代码详解"><a href="#gRPC客户端代码详解" class="headerlink" title="gRPC客户端代码详解"></a>gRPC客户端代码详解</h1><p>gRPC官方将自己分为三层组件：Stub、Channel和Transport。</p>
<ul>
<li>Stub层是最上层的代码，gRPC附带的插件可以从.proto文件直接生成Stub层代码，开发人员通过直接调用Stub层的代码调用RPC服务</li>
<li>Channel层是对Transport层功能的抽象，同时提供了很多有用的功能，比如服务发现和负载均衡。。</li>
<li>Transport层承担了将字节从网络中取出和放入数据的工作，有三种实现Netty、okHttp、inProgress。Transport层是最底层的代码。</li>
</ul>
<p>整个grpc-java项目的代码比较多。从风格上来讲，封装比较多，相对于interface更喜欢使用abstract class，相对于反射更喜欢使用硬编码，而且大量使用了单线程异步调用造成调用栈断裂，与常见的java项目的编码风格有很大差别，阅读起来可能容易不习惯。</p>
<p>在源码层面本文将关注下面这些方面：</p>
<ul>
<li>Channel的初始化过程;</li>
<li>gRPC中的服务发现;</li>
<li>gRPC中的负载均衡</li>
<li>Client与Server之间的数据传输</li>
</ul>
<h2 id="Channel的初始化过程"><a href="#Channel的初始化过程" class="headerlink" title="Channel的初始化过程"></a>Channel的初始化过程</h2><p>通过入门示例可以看到，Channel的初始化过程分三步：</p>
<ol>
<li>调用forTarget方法创建<code>io.grpc.ManagedChannelBuilder</code>;</li>
<li>配置各种选项，不论如何配置，返回的总是<code>io.grpc.ManagedChannelBuilder</code>对象;</li>
<li>调用build方法创建<code>io.grpc.ManagedChannel</code>。</li>
</ol>
<h3 id="forTarget方法"><a href="#forTarget方法" class="headerlink" title="forTarget方法"></a><code>forTarget</code>方法</h3><p>gRPC这里设计比较繁琐，过程比较绕。<code>forTarget</code>方法的实际功能就是<strong>把参数target赋值给<code>io.grpc.ManagedChannelBuilder</code>的内部变量<code>target</code></strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static ManagedChannelBuilder&lt;?&gt; forTarget(String target) &#123;</span><br><span class="line">	return ManagedChannelProvider.provider().builderForTarget(target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>io.grpc.ManagedChannelProvider.provider()</code>会返回一个<code>io.grpc.ManagedChannelProvider</code>实现。有哪些<code>io.grpc.ManagedChannelProvider</code>实现是在<code>io.grpc.ManagedChannelProvider</code>中以硬编码形式确定的，这里其实存在利用反射改进的空间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private static final class HardcodedClasses implements Iterable&lt;Class&lt;?&gt;&gt; &#123;</span><br><span class="line">	@Override</span><br><span class="line">	public Iterator&lt;Class&lt;?&gt;&gt; iterator() &#123;</span><br><span class="line">		List&lt;Class&lt;?&gt;&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">		try &#123;</span><br><span class="line">			list.add(Class.forName(&quot;io.grpc.okhttp.OkHttpChannelProvider&quot;));</span><br><span class="line">		&#125; catch (ClassNotFoundException ex) &#123;</span><br><span class="line">			// ignore</span><br><span class="line">		&#125;</span><br><span class="line">		try &#123;</span><br><span class="line">			list.add(Class.forName(&quot;io.grpc.netty.NettyChannelProvider&quot;));</span><br><span class="line">		&#125; catch (ClassNotFoundException ex) &#123;</span><br><span class="line">		// ignore</span><br><span class="line">		&#125;</span><br><span class="line">		return list.iterator();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上就根据依赖的jar包不同就只有两个实现，一个netty的，一个okhttp的。如果像入门示例项目一样只配置了netty实现,那就只有netty的。<code>io.grpc.netty.NettyChannelProvider</code>的buildForTarget方法调用的是<code>io.grpc.netty.NettyChannelBuilder</code>的<code>forTarget</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public NettyChannelBuilder builderForTarget(String target) &#123;</span><br><span class="line">	return NettyChannelBuilder.forTarget(target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而<code>io.grpc.netty.NettyChannelBuilder</code>继承自<code>io.grpc.internal.AbstractManagedChannelImplBuilder</code>，<code>forTarget</code>方法实际上调用了父类的构造函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NettyChannelBuilder(String target) &#123;</span><br><span class="line">	super(target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static NettyChannelBuilder forTarget(String target) &#123;</span><br><span class="line">	return new NettyChannelBuilder(target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>io.grpc.internal.AbstractManagedChannelImplBuilder</code>的构造函数最终会是把参数赋值给<code>target</code>变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protected AbstractManagedChannelImplBuilder(String target) &#123;</span><br><span class="line">	this.target = Preconditions.checkNotNull(target, &quot;target&quot;);</span><br><span class="line">	this.directServerAddress = null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="build方法"><a href="#build方法" class="headerlink" title="build方法"></a><code>build</code>方法</h3><p>从前文可以看到，实际初始化的<code>io.grpc.ManagedChannelBuilder</code>实际上是<code>io.grpc.netty.NettyChannelBuilder</code>，其<code>build</code>方法实现在其父类<code>io.grpc.internal.AbstractManagedChannelImplBuilder</code>中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public ManagedChannel build() &#123;</span><br><span class="line">	return new ManagedChannelOrphanWrapper(new ManagedChannelImpl(</span><br><span class="line">		this,</span><br><span class="line">		buildTransportFactory(),</span><br><span class="line">		// TODO(carl-mastrangelo): Allow clients to pass this in</span><br><span class="line">		new ExponentialBackoffPolicy.Provider(),</span><br><span class="line">		SharedResourcePool.forResource(GrpcUtil.SHARED_CHANNEL_EXECUTOR),</span><br><span class="line">		GrpcUtil.STOPWATCH_SUPPLIER,</span><br><span class="line">		getEffectiveInterceptors(),</span><br><span class="line">		TimeProvider.SYSTEM_TIME_PROVIDER));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的<code>io.grpc.internal.ManagedChannelOrphanWrapper</code>和<code>io.grpc.internal.ManagedChannelImpl</code>其实都是<code>io.grpc.ManagedChannel</code>的实现。<code>io.grpc.internal.ManagedChannelOrphanWrapper</code>从功能上分析没有任何作用，<code>io.grpc.internal.ManagedChannelOrphanWrapper</code>会为<code>io.grpc.ManagedChannel</code>创建弱引用，并被放置到ReferenceQueue中。如果Channel是单例的，那么意义不大；如果客户端被重复创建却没有被关闭，那么ReferenceQueue中会留下相应的引用记录，可能有助于排查问题。</p>
<p><code>io.grpc.internal.ManagedChannelImpl</code>构造方法的几个参数中，除了第一个参数是builder本身，第二个参数是用来创建Transport的Factory，第三个参数是后台连接重试策略，第四个参数是gRPC的全局线程池，第五个和第七个都是和时间相关的对象，主要用于日志中，第六个是客户端调用时的interceptor。在<code>io.grpc.netty.NettyChannelBuilder</code>中，<code>buildTransportFactory</code>方法会创建一个<code>io.grpc.netty.NettyChannelBuilder.NettyTransportFactory</code>。</p>
<h2 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h2><p>前文的入门示例中直接写了target，只能连接单个Server。如果有多个可以提供服务的Server，那么就需要有一种方式通过单个target发现这些Server。在<code>io.grpc.ManagedChannelBuilder</code>中有一个<code>nameResolverFactory</code>方法，可以用来指定如何解析<code>target</code>地址，发现多个服务端。</p>
<h3 id="nameResolverFactory方法"><a href="#nameResolverFactory方法" class="headerlink" title="nameResolverFactory方法"></a><code>nameResolverFactory</code>方法</h3><p>这个方法的实现也在<code>io.grpc.internal.AbstractManagedChannelImplBuilder</code>中，如果用户有自己的<code>io.grpc.NameResolver.Factory</code>实现的话可以通过<code>nameResolverFactory</code>方法指定,gRPC就会使用用户自己的<code>io.grpc.NameResolver.Factroy</code>实现代替gRPC自己的默认实现，否则会使用<code>io.grpc.NameResolverRegistry</code>中的默认实现。</p>
<p><code>io.grpc.NameResolverRegistry</code>会通过硬编码加载<code>io.grpc.NameResolverProvider</code>实现，并创建一个与之有关的<code>io.grpc.NameResolver.Factory</code>的实现。目前硬编码加载的<code>io.grpc.NameResolverProvider</code>实现只有<code>io.grpc.internal.DnsNameResolverProvider</code>一种。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">private final NameResolver.Factory factory = new NameResolverFactory();</span><br><span class="line">@GuardedBy(&quot;this&quot;)</span><br><span class="line">private final LinkedHashSet&lt;NameResolverProvider&gt; allProviders = new LinkedHashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">private synchronized void addProvider(NameResolverProvider provider) &#123;</span><br><span class="line">	checkArgument(provider.isAvailable(), &quot;isAvailable() returned false&quot;);</span><br><span class="line">	allProviders.add(provider);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static synchronized NameResolverRegistry getDefaultRegistry() &#123;</span><br><span class="line">	if (instance == null) &#123;</span><br><span class="line">		List&lt;NameResolverProvider&gt; providerList = ServiceProviders.loadAll(</span><br><span class="line">			NameResolverProvider.class,</span><br><span class="line">			getHardCodedClasses(),</span><br><span class="line">			NameResolverProvider.class.getClassLoader(),</span><br><span class="line">			new NameResolverPriorityAccessor());</span><br><span class="line">		if (providerList.isEmpty()) &#123;</span><br><span class="line">			logger.warning(&quot;No NameResolverProviders found via ServiceLoader, including for DNS. This &quot;</span><br><span class="line">			+ &quot;is probably due to a broken build. If using ProGuard, check your configuration&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		instance = new NameResolverRegistry();</span><br><span class="line">		for (NameResolverProvider provider : providerList) &#123;</span><br><span class="line">			logger.fine(&quot;Service loader found &quot; + provider);</span><br><span class="line">			if (provider.isAvailable()) &#123;</span><br><span class="line">				instance.addProvider(provider);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		instance.refreshProviders();</span><br><span class="line">	&#125;</span><br><span class="line">	return instance;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">public NameResolver.Factory asFactory() &#123;</span><br><span class="line">	return factory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@VisibleForTesting</span><br><span class="line">static List&lt;Class&lt;?&gt;&gt; getHardCodedClasses() &#123;</span><br><span class="line">	ArrayList&lt;Class&lt;?&gt;&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">	try &#123;</span><br><span class="line">		list.add(Class.forName(&quot;io.grpc.internal.DnsNameResolverProvider&quot;));</span><br><span class="line">	&#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">		logger.log(Level.FINE, &quot;Unable to find DNS NameResolver&quot;, e);</span><br><span class="line">	&#125;</span><br><span class="line">	return Collections.unmodifiableList(list);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private final class NameResolverFactory extends NameResolver.Factory &#123;</span><br><span class="line">	@Override</span><br><span class="line">	@Nullable</span><br><span class="line">	public NameResolver newNameResolver(URI targetUri, NameResolver.Args args) &#123;</span><br><span class="line">		List&lt;NameResolverProvider&gt; providers = providers();</span><br><span class="line">		for (NameResolverProvider provider : providers) &#123;</span><br><span class="line">			NameResolver resolver = provider.newNameResolver(targetUri, args);</span><br><span class="line">			if (resolver != null) &#123;</span><br><span class="line">				return resolver;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public String getDefaultScheme() &#123;</span><br><span class="line">		List&lt;NameResolverProvider&gt; providers = providers();</span><br><span class="line">		if (providers.isEmpty()) &#123;</span><br><span class="line">			return &quot;unknown&quot;;</span><br><span class="line">		&#125;</span><br><span class="line">		return providers.get(0).getDefaultScheme();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>getDefaultSchema</code>会匹配<code>target</code>中的schema（如dns），如果匹配的上，就使用相应的<code>NameResolver.Factory</code>，返回<code>NameResolver</code>决定真正的服务访问地址。</p>
<h3 id="io-grpc-NameResolver"><a href="#io-grpc-NameResolver" class="headerlink" title="io.grpc.NameResolver"></a><code>io.grpc.NameResolver</code></h3><p>我们来看<code>io.grpc.NameResolver</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">public abstract class NameResolver &#123;</span><br><span class="line"></span><br><span class="line">	public abstract String getServiceAuthority();</span><br><span class="line">	</span><br><span class="line">	public void start(final Listener listener) &#123;</span><br><span class="line">	if (listener instanceof Listener2) &#123;</span><br><span class="line">			start((Listener2) listener);</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			start(new Listener2() &#123;</span><br><span class="line">				@Override</span><br><span class="line">				public void onError(Status error) &#123;</span><br><span class="line">				listener.onError(error);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				@Override</span><br><span class="line">				public void onResult(ResolutionResult resolutionResult) &#123;</span><br><span class="line">					listener.onAddresses(resolutionResult.getAddresses(), resolutionResult.getAttributes());</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void start(Listener2 listener) &#123;</span><br><span class="line">		start((Listener) listener);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public abstract void shutdown();</span><br><span class="line">	</span><br><span class="line">	public void refresh() &#123;&#125;</span><br><span class="line">	</span><br><span class="line">	@ThreadSafe</span><br><span class="line">	public interface Listener &#123;</span><br><span class="line"></span><br><span class="line">		void onAddresses(List&lt;EquivalentAddressGroup&gt; servers, @ResolutionResultAttr Attributes attributes);</span><br><span class="line"></span><br><span class="line">		void onError(Status error);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public abstract static class Listener2 implements Listener &#123;</span><br><span class="line"></span><br><span class="line">		@Override</span><br><span class="line">		public final void onAddresses(</span><br><span class="line">			List&lt;EquivalentAddressGroup&gt; servers, @ResolutionResultAttr Attributes attributes) &#123;</span><br><span class="line">			onResult(</span><br><span class="line">			ResolutionResult.newBuilder().setAddresses(servers).setAttributes(attributes).build());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		public abstract void onResult(ResolutionResult resolutionResult);</span><br><span class="line"></span><br><span class="line">		@Override</span><br><span class="line">		public abstract void onError(Status error);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static final class ResolutionResult &#123;</span><br><span class="line">		private final List&lt;EquivalentAddressGroup&gt; addresses;</span><br><span class="line">		@ResolutionResultAttr</span><br><span class="line">		private final Attributes attributes;</span><br><span class="line">		@Nullable</span><br><span class="line">		private final ConfigOrError serviceConfig;</span><br><span class="line"></span><br><span class="line">		ResolutionResult(</span><br><span class="line">			List&lt;EquivalentAddressGroup&gt; addresses,</span><br><span class="line">			@ResolutionResultAttr Attributes attributes,</span><br><span class="line">			ConfigOrError serviceConfig) &#123;</span><br><span class="line">			this.addresses = Collections.unmodifiableList(new ArrayList&lt;&gt;(addresses));</span><br><span class="line">			this.attributes = checkNotNull(attributes, &quot;attributes&quot;);</span><br><span class="line">			this.serviceConfig = serviceConfig;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		public static Builder newBuilder() &#123;</span><br><span class="line">		  return new Builder();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		public Builder toBuilder() &#123;</span><br><span class="line">		  return newBuilder()</span><br><span class="line">			  .setAddresses(addresses)</span><br><span class="line">			  .setAttributes(attributes)</span><br><span class="line">			  .setServiceConfig(serviceConfig);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		public List&lt;EquivalentAddressGroup&gt; getAddresses() &#123;</span><br><span class="line">		  return addresses;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		@ResolutionResultAttr</span><br><span class="line">		public Attributes getAttributes() &#123;</span><br><span class="line">		  return attributes;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		@Nullable</span><br><span class="line">		public ConfigOrError getServiceConfig() &#123;</span><br><span class="line">		  return serviceConfig;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		@ExperimentalApi(&quot;https://github.com/grpc/grpc-java/issues/1770&quot;)</span><br><span class="line">		public static final class Builder &#123;</span><br><span class="line">			private List&lt;EquivalentAddressGroup&gt; addresses = Collections.emptyList();</span><br><span class="line">			private Attributes attributes = Attributes.EMPTY;</span><br><span class="line">			@Nullable</span><br><span class="line">			private ConfigOrError serviceConfig;</span><br><span class="line">			Builder() &#123;&#125;</span><br><span class="line"></span><br><span class="line">			public Builder setAddresses(List&lt;EquivalentAddressGroup&gt; addresses) &#123;</span><br><span class="line">				this.addresses = addresses;</span><br><span class="line">				return this;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			public Builder setAttributes(Attributes attributes) &#123;</span><br><span class="line">				this.attributes = attributes;</span><br><span class="line">				return this;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			public Builder setServiceConfig(@Nullable ConfigOrError serviceConfig) &#123;</span><br><span class="line">				this.serviceConfig = serviceConfig;</span><br><span class="line">				return this;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			public ResolutionResult build() &#123;</span><br><span class="line">				return new ResolutionResult(addresses, attributes, serviceConfig);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在客户端首次连接服务端的时候会调用<code>Listener2</code>的<code>start</code>方法，需要更新的时候会调用<code>refresh</code>方法。当<code>Listener2</code>接收到服务端地址时，会调用onResult方法。</p>
<h3 id="io-grpc-internal-DnsNameResolver"><a href="#io-grpc-internal-DnsNameResolver" class="headerlink" title="io.grpc.internal.DnsNameResolver"></a><code>io.grpc.internal.DnsNameResolver</code></h3><p>由于gRPC支持长连接，所以如果直连的话只会访问一个域名下的一台服务器，即首次连接时通过DNS返回IP地址。<code>io.grpc.internal.DnsNameResolverProvider</code>是对<code>io.grpc.internal.DnsNameResolver</code>的简单封装，只支持以<code>dns:///</code>开头的地址。<code>io.grpc.internal.DnsNameResolver</code>会根据<code>target</code>获取该host下所有关联的IP，即通过DNS解析出所有的服务端IP地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public final class DnsNameResolverProvider extends NameResolverProvider &#123;</span><br><span class="line"></span><br><span class="line">  private static final String SCHEME = &quot;dns&quot;;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public DnsNameResolver newNameResolver(URI targetUri, NameResolver.Args args) &#123;</span><br><span class="line">    if (SCHEME.equals(targetUri.getScheme())) &#123;</span><br><span class="line">      String targetPath = Preconditions.checkNotNull(targetUri.getPath(), &quot;targetPath&quot;);</span><br><span class="line">      Preconditions.checkArgument(targetPath.startsWith(&quot;/&quot;),</span><br><span class="line">          &quot;the path component (%s) of the target (%s) must start with &apos;/&apos;&quot;, targetPath, targetUri);</span><br><span class="line">      String name = targetPath.substring(1);</span><br><span class="line">      return new DnsNameResolver(</span><br><span class="line">          targetUri.getAuthority(),</span><br><span class="line">          name,</span><br><span class="line">          args,</span><br><span class="line">          GrpcUtil.SHARED_CHANNEL_EXECUTOR,</span><br><span class="line">          Stopwatch.createUnstarted(),</span><br><span class="line">          InternalServiceProviders.isAndroid(getClass().getClassLoader()));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public String getDefaultScheme() &#123;</span><br><span class="line">    return SCHEME;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  protected boolean isAvailable() &#123;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  protected int priority() &#123;</span><br><span class="line">    return 5;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>io.grpc.internal.DnsNameResolver</code>中的<code>start</code>和<code>refresh</code>方法都调用的是<code>resolve</code>方法，而<code>resolve</code>方法是执行了一个继承自<code>Runnable</code>的<code>Resolve</code>接口。</p>
<p><img src="//liumenghan.github.io/2019/10/07/grpc-in-depth/DnsNameResolver-start.png" alt="DnsNameResolver"></p>
<p>在有代理的情况下，<code>Resolve</code>的<code>resolveInternal</code>会根据代理返回的<code>ProxiedSocketAddress</code>创建<code>EquivalentAddressGroup</code>作为服务端列表返回，并设置空config；否则会调用<code>resolveAll</code>方法获取服务端列表，并调用<code>parseServiceConfig</code>方法设置config。<code>resolveAll</code>方法返回的<code>ResolutionResults</code>有三个变量<code>addresses</code>、<code>txtRecords</code>和<code>balancerAddresses</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">@VisibleForTesting</span><br><span class="line">static ResolutionResults resolveAll(</span><br><span class="line">	AddressResolver addressResolver,</span><br><span class="line">	@Nullable ResourceResolver resourceResolver,</span><br><span class="line">	boolean requestSrvRecords,</span><br><span class="line">	boolean requestTxtRecords,</span><br><span class="line">	String name) &#123;</span><br><span class="line">	List&lt;? extends InetAddress&gt; addresses = Collections.emptyList();</span><br><span class="line">	Exception addressesException = null;</span><br><span class="line">	List&lt;EquivalentAddressGroup&gt; balancerAddresses = Collections.emptyList();</span><br><span class="line">	Exception balancerAddressesException = null;</span><br><span class="line">	List&lt;String&gt; txtRecords = Collections.emptyList();</span><br><span class="line">	Exception txtRecordsException = null;</span><br><span class="line"></span><br><span class="line">	try &#123;</span><br><span class="line">		addresses = addressResolver.resolveAddress(name);</span><br><span class="line">	&#125; catch (Exception e) &#123;</span><br><span class="line">	addressesException = e;</span><br><span class="line">	&#125;</span><br><span class="line">	if (resourceResolver != null) &#123;</span><br><span class="line">		if (requestSrvRecords) &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				balancerAddresses =</span><br><span class="line">					resourceResolver.resolveSrv(addressResolver, GRPCLB_NAME_PREFIX + name);</span><br><span class="line">			&#125; catch (Exception e) &#123;</span><br><span class="line">				balancerAddressesException = e;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (requestTxtRecords) &#123;</span><br><span class="line">			boolean balancerLookupFailedOrNotAttempted =</span><br><span class="line">				!requestSrvRecords || balancerAddressesException != null;</span><br><span class="line">			boolean dontResolveTxt =</span><br><span class="line">				(addressesException != null) &amp;&amp; balancerLookupFailedOrNotAttempted;</span><br><span class="line">			if (!dontResolveTxt) &#123;</span><br><span class="line">				try &#123;</span><br><span class="line">					txtRecords = resourceResolver.resolveTxt(SERVICE_CONFIG_NAME_PREFIX + name);</span><br><span class="line">				&#125; catch (Exception e) &#123;</span><br><span class="line">				txtRecordsException = e;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;	</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	try &#123;</span><br><span class="line">		if (addressesException != null</span><br><span class="line">			&amp;&amp; (balancerAddressesException != null || balancerAddresses.isEmpty())) &#123;</span><br><span class="line">			Throwables.throwIfUnchecked(addressesException);</span><br><span class="line">			throw new RuntimeException(addressesException);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; finally &#123;</span><br><span class="line">		if (addressesException != null) &#123;</span><br><span class="line">			logger.log(Level.FINE, &quot;Address resolution failure&quot;, addressesException);</span><br><span class="line">		&#125;</span><br><span class="line">		if (balancerAddressesException != null) &#123;</span><br><span class="line">			logger.log(Level.FINE, &quot;Balancer resolution failure&quot;, balancerAddressesException);</span><br><span class="line">		&#125;</span><br><span class="line">		if (txtRecordsException != null) &#123;</span><br><span class="line">			logger.log(Level.FINE, &quot;ServiceConfig resolution failure&quot;, txtRecordsException);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return new ResolutionResults(addresses, txtRecords, balancerAddresses);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>addressResolver</code>的<code>resolveAddress</code>方法实际是调用JDK的<code>java.net.InetAddress</code>的<code>getAllByName</code>方法，即根据host通过DNS返回一系列服务端列表。<code>resourceResolver</code>根据LDAP协议获取指定命名空间下的服务端列表地址。<code>txtRecords</code>和<code>balancerAddresses</code>是和LDAP相关的参数，方法入参<code>requestSrvRecords</code>和<code>requestTxtRecords</code>的默认值都是false。由于LDAP不是特别常用，这里就不深入展开了。</p>
<h3 id="NameResolverListener的onResult"><a href="#NameResolverListener的onResult" class="headerlink" title="NameResolverListener的onResult"></a><code>NameResolverListener</code>的<code>onResult</code></h3><p>当<code>NameResolverListener</code>获取解析结果后会调用<code>onResult</code>方法，进而会调用<code>io.grpc.LoadBalancer</code>的<code>handleResolvedAddresses</code>方法。</p>
<p><img src="//liumenghan.github.io/2019/10/07/grpc-in-depth/call-handle-resolved-response.png" alt="获取解析结果后调用handleResolvedAddresses方法"></p>
<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p><code>io.grpc.ManagedChannel</code>初始化的时候可以通过<code>defaultLoadBalancingPolicy</code>方法指定负载均衡策略，实际是根据<code>defaultLoadBalancingPolicy</code>创建了一个<code>io.grpc.internal.AutoConfiguredLoadBalancerFactory</code>对象。<code>io.grpc.internal.AutoConfiguredLoadBalancerFactory</code>则通过<code>io.grpc.LoadBalancerRegistry</code>获取对应名称的负载均衡策略。<code>io.grpc.LoadBalancerProvider</code>的<code>getPolicyName</code>方法指定负载均衡策略名称，<code>newLoadBalancer</code>返回负载均衡<code>io.grpc.LoadBalancer</code>的具体实现。如果想要添加自定义负载均衡策略，需要调用<code>io.grpc.LoadBalancerRegistry</code>的<code>registry</code>方法，并自己实现<code>io.grpc.LoadBalancerProvider</code>和<code>io.grpc.LoadBalancer</code>，并指定负载均衡策略名称即可。<br><img src="//liumenghan.github.io/2019/10/07/grpc-in-depth/defaulLoadBalancingPolicy.png" alt="defaultLoadBalancingPolicy方法"></p>
<h3 id="io-grpc-LoadBalancer-SubchannelPicker"><a href="#io-grpc-LoadBalancer-SubchannelPicker" class="headerlink" title="io.grpc.LoadBalancer.SubchannelPicker"></a><code>io.grpc.LoadBalancer.SubchannelPicker</code></h3><p><code>io.grpc.LoadBalancer</code>的核心逻辑实际在<code>SubchannelPicker</code>中。<code>pickSubchannel</code>方法会返回的PickResult中包含真正可用的subchannel，用来进行后续的数据传输。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public abstract static class SubchannelPicker &#123;</span><br><span class="line">	/**</span><br><span class="line">	* Make a balancing decision for a new RPC.</span><br><span class="line">	*</span><br><span class="line">	* @param args the pick arguments</span><br><span class="line">	* @since 1.3.0</span><br><span class="line">	*/</span><br><span class="line">	public abstract PickResult pickSubchannel(PickSubchannelArgs args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>gRPC默认提供了两种负载均衡实现策略：<code>prick_first</code>和<code>round_robin</code>。前者总会使用第一个可用的服务端，后者则是简单轮询。</p>
<h3 id="handleResolvedAddresses"><a href="#handleResolvedAddresses" class="headerlink" title="handleResolvedAddresses"></a><code>handleResolvedAddresses</code></h3><p>当服务端列表更新时，会调用<code>io.grpc.LoadBalancer</code>的<code>handleResolvedAddresses</code>方法更新可用的subchannel。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void handleResolvedAddresses(ResolvedAddresses resolvedAddresses) &#123;</span><br><span class="line">	List&lt;EquivalentAddressGroup&gt; servers = resolvedAddresses.getAddresses();</span><br><span class="line">	if (subchannel == null) &#123;</span><br><span class="line">		final Subchannel subchannel = helper.createSubchannel(</span><br><span class="line">		CreateSubchannelArgs.newBuilder()</span><br><span class="line">			.setAddresses(servers)</span><br><span class="line">			.build());</span><br><span class="line">		subchannel.start(new SubchannelStateListener() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void onSubchannelState(ConnectivityStateInfo stateInfo) &#123;</span><br><span class="line">				processSubchannelState(subchannel, stateInfo);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		this.subchannel = subchannel;</span><br><span class="line">		helper.updateBalancingState(CONNECTING, new Picker(PickResult.withSubchannel(subchannel)));</span><br><span class="line">		subchannel.requestConnection();</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		subchannel.updateAddresses(servers);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是首次调用(subchannel == null) 会创建subchannel，其实现是<code>io.grpc.internal.ManagedChannelImpl.SubchannelImpl</code>，创建的过程中会创建<code>io.grpc.internal.InternalSubchannel</code>。然后调用<code>io.grpc.internal.ManagedChannelImpl</code>的<code>updateBalancingState</code>方法，把<code>subchannelPicker</code>更新为实现<code>Picker</code>，然后开启subchannel的连接。</p>
<p><img src="//liumenghan.github.io/2019/10/07/grpc-in-depth/start-subchannel.png" alt="开启subchannel链接"></p>
<p>在开启subchannel的连接过程中，会调用<code>io.grpc.internal.InternalSubchannel</code>的<code>obtainActiveTransport</code>方法。</p>
<p>这里的transportFactory就是上面提到<code>io.grpc.ManagedChannelBuilder</code>调用<code>build</code>初始化时调用<code>buildTransportFactory</code>方法返回的，依赖于Transport层的具体实现。在netty实现中，返回的是<code>io.grpc.netty.NettyClientTransport</code>。</p>
<h2 id="传输"><a href="#传输" class="headerlink" title="传输"></a>传输</h2><p>gRPC客户端发起Request时，stub会调用<code>ClientCalls</code>的<code>startCall</code>方法，最终会调用<code>io.grpc.internal.ManagedChannelImpl.ChannelTransportProvider</code>的<code>get</code>方法获取<code>io.grc.internal.ClientTransport</code>。</p>
<p><img src="//liumenghan.github.io/2019/10/07/grpc-in-depth/start-call.png" alt="gRPC客户端发起Request时调用ChannelTransportProvider的get方法"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public ClientTransport get(PickSubchannelArgs args) &#123;</span><br><span class="line">SubchannelPicker pickerCopy = subchannelPicker;</span><br><span class="line">	if (shutdown.get()) &#123;</span><br><span class="line">		return delayedTransport;</span><br><span class="line">	&#125;</span><br><span class="line">	if (pickerCopy == null) &#123;</span><br><span class="line">		final class ExitIdleModeForTransport implements Runnable &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				exitIdleMode();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		syncContext.execute(new ExitIdleModeForTransport());</span><br><span class="line">		return delayedTransport;</span><br><span class="line">	&#125;</span><br><span class="line">	PickResult pickResult = pickerCopy.pickSubchannel(args);</span><br><span class="line">	ClientTransport transport = GrpcUtil.getTransportFromPickResult(</span><br><span class="line">		pickResult, args.getCallOptions().isWaitForReady());</span><br><span class="line">	if (transport != null) &#123;</span><br><span class="line">		return transport;</span><br><span class="line">	&#125;</span><br><span class="line">	return delayedTransport;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果subchannelPicker存在，会使用subchannelPicker进行选择；如果是首次访问服务端时subchannel肯定不存在，会使用syncContext异步执行<code>exitIdleMode</code>方法初始化。syncContext是一个<strong>单线程执行队列，可以保证先提交的任务先执行</strong>。delayedTransport的执行也依赖于syncContext，这就保证了delayedTransport中的方法执行一定会在<code>exitIdleMode</code>方法之后。</p>
<h3 id="首次访问服务端时执行exidIdleMode方法"><a href="#首次访问服务端时执行exidIdleMode方法" class="headerlink" title="首次访问服务端时执行exidIdleMode方法"></a>首次访问服务端时执行<code>exidIdleMode</code>方法</h3><p><code>exitIdleMode</code>方法会初始化<code>NameResolver</code>和<code>LoadBalancer</code>，并会启动<code>NameResolverListener</code>。当解析完成后会调用<code>NameResolverListener</code>的<code>onResult</code>方法，进而调用<code>LoadBalancer</code>的<code>handleResolvedAddresses</code>方法创建subchannelPicker、创建并连接subchannel。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@VisibleForTesting</span><br><span class="line">void exitIdleMode() &#123;</span><br><span class="line">	syncContext.throwIfNotInThisSynchronizationContext();</span><br><span class="line">	if (shutdown.get() || panicMode) &#123;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	if (inUseStateAggregator.isInUse()) &#123;</span><br><span class="line">		cancelIdleTimer(false);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		rescheduleIdleTimer();</span><br><span class="line">	&#125;</span><br><span class="line">	if (lbHelper != null) &#123;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	channelLogger.log(ChannelLogLevel.INFO, &quot;Exiting idle mode&quot;);</span><br><span class="line">	LbHelperImpl lbHelper = new LbHelperImpl();</span><br><span class="line">	lbHelper.lb = loadBalancerFactory.newLoadBalancer(lbHelper);</span><br><span class="line">	this.lbHelper = lbHelper;</span><br><span class="line"></span><br><span class="line">	NameResolverListener listener = new NameResolverListener(lbHelper, nameResolver);</span><br><span class="line">	nameResolver.start(listener);</span><br><span class="line">	nameResolverStarted = true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h3><p>发送Request时会调用<code>ConnectionClientTransport</code>的<code>newStream</code>方法返回一个<code>io.grpc.internal.ClientStream</code>对象,而首次调用会通过delayedTransport延迟调用<code>newStream</code>方法。</p>
<p><img src="//liumenghan.github.io/2019/10/07/grpc-in-depth/calling-new-stream.png" alt="调用newStream的调用栈"></p>
<p>netty实现会返回一个<code>io.grpc.netty.shaded.io.grpc.netty.NettyClientStream</code>对象。<code>io.grpc.internal.ClientStream</code>下有两个子类,<code>TransportState</code>负责处理传输状态，<code>Sink</code>负责写入数据。</p>
<p>在进行一系列http2相关设置后，会调用<code>io.grpc.internal.ClientStream</code>的<code>start</code>方法，为<code>TransportState</code>设置监听并通过<code>Sink</code>写入Header。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public final void start(ClientStreamListener listener) &#123;</span><br><span class="line">	transportState().setListener(listener);</span><br><span class="line">	if (!useGet) &#123;</span><br><span class="line">		abstractClientStreamSink().writeHeaders(headers, null);</span><br><span class="line">		headers = null;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化结束后，调用requestObserver的<code>onNext</code>方法会调用<code>io.grpc.internal.ClientCallImpl</code>的<code>sendMessage</code>方法，将protobuf对象转换成<code>InputStream</code>，并作为参数调用<code>io.grpc.internal.ClientStream</code>的<code>writeMessage</code>方法，进而调用<code>io.grpc.internal.MessageFramer</code>的<code>writePayload</code>方法，最终调用<code>writeToOutputStream</code>方法将内容写入Http的OutputStream。如果是参数是stream形式会继续调用flush。</p>
<p><img src="//liumenghan.github.io/2019/10/07/grpc-in-depth/request-on-next.png" alt="onNext"></p>
<p>调用requestObserver的<code>onCompleted</code>方法会调用<code>io.grpc.internal.ClientCallImpl</code>的<code>halfClose</code>方法，进而会调用<code>io.grpc.internal.MessageFramer</code>的<code>endOfMessages</code>，flush并结束发送消息。</p>
<p><img src="//liumenghan.github.io/2019/10/07/grpc-in-depth/request-on-complete.png" alt="onComplete"></p>
<h3 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h3><p><img src="//liumenghan.github.io/2019/10/07/grpc-in-depth/response-on-next.png" alt="onNext"></p>
<p>客户端接受到Response会调用ClientStreamListener的<code>messagesAvailable</code>方法，并通过同步线程池最终调用StreamObserver的<code>onNext</code>方法接收数据。</p>
<p><img src="//liumenghan.github.io/2019/10/07/grpc-in-depth/response-on-complete.png" alt="onComplete"></p>
<p>当返回结束时会调用TransportState的<code>transportReportStatus</code>方法关闭请求，进而调用ClientStreamListener的<code>closed</code>方法关闭监听，进而调用StreamObserver的<code>onClose</code>方法。</p>
<h3 id="gRPC通信格式"><a href="#gRPC通信格式" class="headerlink" title="gRPC通信格式"></a>gRPC通信格式</h3><p>gRPC发送的请求发送方法是POST，路径是/${serviceName}/${methodName}，content-type为content-type = application/grpc+proto。</p>
<h4 id="Request-1"><a href="#Request-1" class="headerlink" title="Request"></a>Request</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HEADERS (flags = END_HEADERS)</span><br><span class="line">:method = POST</span><br><span class="line">:scheme = http</span><br><span class="line">:path = /RouteGuide/getPoint</span><br><span class="line">grpc-timeout = 1S</span><br><span class="line">content-type = application/grpc+proto</span><br><span class="line">grpc-encoding = gzip</span><br><span class="line"></span><br><span class="line">DATA (flags = END_STREAM)</span><br><span class="line">&lt;Length-Prefixed Message&gt;</span><br></pre></td></tr></table></figure>

<h4 id="Response-1"><a href="#Response-1" class="headerlink" title="Response"></a>Response</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">HEADERS (flags = END_HEADERS)</span><br><span class="line">:status = 200</span><br><span class="line">grpc-encoding = gzip</span><br><span class="line">content-type = application/grpc+proto</span><br><span class="line"></span><br><span class="line">DATA</span><br><span class="line">&lt;Length-Prefixed Message&gt;</span><br><span class="line"></span><br><span class="line">HEADERS (flags = END_STREAM, END_HEADERS)</span><br><span class="line">grpc-status = 0 # OK</span><br><span class="line">trace-proto-bin = jher831yy13JHy3hc</span><br></pre></td></tr></table></figure>

<h1 id="扩展gRPC"><a href="#扩展gRPC" class="headerlink" title="扩展gRPC"></a>扩展gRPC</h1><h3 id="自定义基于zookeeper的NameResolver-Factory实现"><a href="#自定义基于zookeeper的NameResolver-Factory实现" class="headerlink" title="自定义基于zookeeper的NameResolver.Factory实现"></a>自定义基于zookeeper的<code>NameResolver.Factory</code>实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">public class CuratorNameResolver extends NameResolver &#123;</span><br><span class="line">	CuratorFramework curatorFramework;</span><br><span class="line">	String basePath;</span><br><span class="line">	String serviceAuthority;</span><br><span class="line">	private Listener2 listener;</span><br><span class="line"></span><br><span class="line">	public CuratorNameResolver(CuratorFramework curatorFramework, String basePath, String serviceAuthority) &#123;</span><br><span class="line">		this.curatorFramework = curatorFramework;</span><br><span class="line">		this.basePath = basePath;</span><br><span class="line">		this.serviceAuthority = serviceAuthority;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void start(Listener2 listener) &#123;</span><br><span class="line">		this.curatorFramework.start();</span><br><span class="line">		this.listener = listener;</span><br><span class="line">		refresh();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void refresh() &#123;</span><br><span class="line">		List&lt;EquivalentAddressGroup&gt; servers = new ArrayList&lt;&gt;();</span><br><span class="line">		try &#123;</span><br><span class="line">			List&lt;EquivalentAddressGroup&gt; addresses = curatorFramework.getChildren()</span><br><span class="line">					.forPath(basePath)</span><br><span class="line">					.stream().map(address -&gt;&#123;</span><br><span class="line">						try &#123;</span><br><span class="line">							URI uri = new URI(&quot;http://&quot; + address);</span><br><span class="line">							return new EquivalentAddressGroup(</span><br><span class="line">								new InetSocketAddress(uri.getHost(), uri.getPort()));</span><br><span class="line">						&#125;catch (Exception e)&#123;</span><br><span class="line">							listener.onError(Status.INTERNAL);</span><br><span class="line">							return null;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;).collect(Collectors.toList());</span><br><span class="line">			listener.onResult(ResolutionResult.newBuilder().setAddresses(addresses).build());</span><br><span class="line"></span><br><span class="line">		&#125; catch (Exception e) &#123;</span><br><span class="line">			listener.onError(Status.INTERNAL);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public String getServiceAuthority() &#123;</span><br><span class="line">		return this.serviceAuthority;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void shutdown() &#123;</span><br><span class="line">		this.curatorFramework.close();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static class Factory extends NameResolver.Factory&#123;</span><br><span class="line">		@Override</span><br><span class="line">		public NameResolver newNameResolver(URI targetUri, Args args) &#123;</span><br><span class="line">			String address = targetUri.getHost() + &quot;:&quot; + targetUri.getPort();</span><br><span class="line">			String authority = null == targetUri.getAuthority() ? address : targetUri.getAuthority();</span><br><span class="line">			CuratorFramework curator = CuratorFrameworkFactory.builder()</span><br><span class="line">					.connectString(address)</span><br><span class="line">					.retryPolicy(new ExponentialBackoffRetry(1000, 5))</span><br><span class="line">					.connectionTimeoutMs(1000)</span><br><span class="line">					.sessionTimeoutMs(60000)</span><br><span class="line">					.build();</span><br><span class="line">			return new CuratorNameResolver(curator, targetUri.getPath(), authority);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		@Override</span><br><span class="line">		public String getDefaultScheme() &#123;</span><br><span class="line">			return &quot;zookeeper&quot;;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义随机负载均衡实现"><a href="#自定义随机负载均衡实现" class="headerlink" title="自定义随机负载均衡实现"></a>自定义随机负载均衡实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">public class RandomLoadBalancer extends LoadBalancer&#123;</span><br><span class="line">	LoadBalancer.Helper helper;</span><br><span class="line"></span><br><span class="line">	private final Map&lt;EquivalentAddressGroup, Subchannel&gt; subchannels =</span><br><span class="line">			new HashMap&lt;&gt;();</span><br><span class="line">	static final Attributes.Key&lt;Ref&lt;ConnectivityStateInfo&gt;&gt; STATE_INFO =</span><br><span class="line">			Attributes.Key.create(&quot;state-info&quot;);</span><br><span class="line"></span><br><span class="line">	public RandomLoadBalancer(LoadBalancer.Helper helper) &#123;</span><br><span class="line">		this.helper = helper;</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	public void handleResolvedAddresses(ResolvedAddresses resolvedAddresses) &#123;</span><br><span class="line">		List&lt;EquivalentAddressGroup&gt; servers = resolvedAddresses.getAddresses();</span><br><span class="line">		for(EquivalentAddressGroup server : servers)&#123;</span><br><span class="line">			List&lt;EquivalentAddressGroup&gt; serverSingletonListt = Collections.singletonList(server);</span><br><span class="line">			Subchannel exists = subchannels.getOrDefault(server, null);</span><br><span class="line">			if(null != exists)&#123;</span><br><span class="line">				exists.updateAddresses(serverSingletonListt);</span><br><span class="line">				continue;</span><br><span class="line">			&#125;</span><br><span class="line">			Attributes.Builder subchannelAttrs = Attributes.newBuilder()</span><br><span class="line">					.set(STATE_INFO,</span><br><span class="line">							new Ref&lt;&gt;(ConnectivityStateInfo.forNonError(IDLE)));</span><br><span class="line">			final Subchannel subchannel = helper.createSubchannel(CreateSubchannelArgs.newBuilder()</span><br><span class="line">							.setAddresses(serverSingletonListt)</span><br><span class="line">							.setAttributes(subchannelAttrs.build())</span><br><span class="line">							.build());</span><br><span class="line">			subchannels.put(server, subchannel);</span><br><span class="line">			subchannel.start(new SubchannelStateListener() &#123;</span><br><span class="line">				@Override</span><br><span class="line">				public void onSubchannelState(ConnectivityStateInfo state) &#123;</span><br><span class="line">					for(Map.Entry&lt;EquivalentAddressGroup, Subchannel&gt; entry : subchannels.entrySet())&#123;</span><br><span class="line">						if(subchannel == entry.getValue())&#123;</span><br><span class="line">							if (state.getState() == SHUTDOWN) &#123;</span><br><span class="line">								subchannels.remove(entry.getKey());</span><br><span class="line">							&#125;</span><br><span class="line">							if (state.getState() == IDLE) &#123;</span><br><span class="line">								subchannel.requestConnection();</span><br><span class="line">							&#125;</span><br><span class="line">							subchannel.getAttributes().get(STATE_INFO).value = state;</span><br><span class="line">							updateBalancingState();</span><br><span class="line">							return;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">			subchannel.requestConnection();</span><br><span class="line">		&#125;</span><br><span class="line">		updateBalancingState();</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	public void handleNameResolutionError(Status error) &#123;</span><br><span class="line">		shutdown();</span><br><span class="line">		helper.updateBalancingState(TRANSIENT_FAILURE, new SubchannelPicker() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public PickResult pickSubchannel(PickSubchannelArgs args) &#123;</span><br><span class="line">				return PickResult.withError(error);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private  void updateBalancingState()&#123;</span><br><span class="line">		boolean ready = true;</span><br><span class="line">		for(Subchannel subchannel : this.subchannels.values())&#123;</span><br><span class="line">			if(subchannel.getAttributes().get(STATE_INFO).value.getState() != READY)&#123;</span><br><span class="line">				helper.updateBalancingState(CONNECTING, new RandomSubchannelPick(subchannels.values()));</span><br><span class="line">				return;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		helper.updateBalancingState(ConnectivityState.READY, new RandomSubchannelPick(subchannels.values()));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void shutdown() &#123;</span><br><span class="line">		for(Iterator&lt;Map.Entry&lt;EquivalentAddressGroup, Subchannel&gt;&gt; itr = subchannels.entrySet().iterator(); itr.hasNext();)&#123;</span><br><span class="line">			Map.Entry&lt;EquivalentAddressGroup, Subchannel&gt; e = itr.next();</span><br><span class="line">			e.getValue().shutdown();</span><br><span class="line">			itr.remove();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	class RandomSubchannelPick extends SubchannelPicker&#123;</span><br><span class="line">		Subchannel[] subchannels;</span><br><span class="line">		Random random = new Random(System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">		public RandomSubchannelPick(Collection&lt;Subchannel&gt; subchannels) &#123;</span><br><span class="line">			this.subchannels = subchannels.stream().toArray(Subchannel[]::new);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		@Override</span><br><span class="line">		public PickResult pickSubchannel(PickSubchannelArgs args) &#123;</span><br><span class="line">			int idx = random.nextInt(subchannels.length);</span><br><span class="line">			return PickResult.withSubchannel(subchannels[idx]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static class Provider extends LoadBalancerProvider&#123;</span><br><span class="line"></span><br><span class="line">		@Override</span><br><span class="line">		public boolean isAvailable() &#123;</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		@Override</span><br><span class="line">		public int getPriority() &#123;</span><br><span class="line">			return 100;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		@Override</span><br><span class="line">		public String getPolicyName() &#123;</span><br><span class="line">			return &quot;random&quot;;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		@Override</span><br><span class="line">		public LoadBalancer newLoadBalancer(LoadBalancer.Helper helper) &#123;</span><br><span class="line">			return new RandomLoadBalancer(helper);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	static final class Ref&lt;T&gt; &#123;</span><br><span class="line">		T value;</span><br><span class="line"></span><br><span class="line">		Ref(T value) &#123;</span><br><span class="line">			this.value = value;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="服务端初始化"><a href="#服务端初始化" class="headerlink" title="服务端初始化"></a>服务端初始化</h3><p>服务端需要把自己的服务地址注册到zookeeper。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">private final int port;</span><br><span class="line">private final Server server;</span><br><span class="line">private String registryPath;</span><br><span class="line">private String address;</span><br><span class="line">CuratorFramework curator = CuratorFrameworkFactory.builder()</span><br><span class="line">		.connectString(&quot;127.0.0.1:2181&quot;)</span><br><span class="line">		.retryPolicy(new ExponentialBackoffRetry(1000, 5))</span><br><span class="line">		.connectionTimeoutMs(1000)</span><br><span class="line">		.sessionTimeoutMs(60000)</span><br><span class="line">		.build();;</span><br><span class="line"></span><br><span class="line">public GreetingServer(int port, String registryPath) throws IOException &#123;</span><br><span class="line">	this.port = port;</span><br><span class="line">	server = ServerBuilder.forPort(port).addService(new GreetingService())</span><br><span class="line">			.build();</span><br><span class="line">	this.registryPath = registryPath;</span><br><span class="line">	this.address =  &quot;localhost:&quot; + port;    //本机网卡不能正确显示地址，直接写死localhost</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Start server.</span><br><span class="line"> */</span><br><span class="line">public void start() throws Exception &#123;</span><br><span class="line">	this.curator.start();</span><br><span class="line">	server.start();;</span><br><span class="line">	this.curator.create()</span><br><span class="line">			.creatingParentContainersIfNeeded()</span><br><span class="line">			.withMode(CreateMode.EPHEMERAL)</span><br><span class="line">			.forPath(registryPath + &quot;/&quot; + address, (&quot;http://&quot; + address).getBytes());</span><br><span class="line"></span><br><span class="line">	System.out.println(&quot;Server started, listening on &quot; + address);</span><br><span class="line">	Runtime.getRuntime().addShutdownHook(new Thread() &#123;</span><br><span class="line">		@Override</span><br><span class="line">		public void run() &#123;</span><br><span class="line">			GreetingServer.this.stop();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="客户端初始化"><a href="#客户端初始化" class="headerlink" title="客户端初始化"></a>客户端初始化</h3><p>客户端需要注册自定义的NameResolverFactory和LoadBalancer。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public GreetingClient(String host, int port, String path) &#123;</span><br><span class="line">	String target = &quot;zookeeper://&quot; + host + &quot;:&quot; + port + path;</span><br><span class="line">	CuratorNameResolver.Factory factory = new CuratorNameResolver.Factory();</span><br><span class="line"></span><br><span class="line">	LoadBalancerRegistry.getDefaultRegistry().register(new RandomLoadBalancer.Provider());</span><br><span class="line">	ManagedChannelBuilder&lt;?&gt; channelBuilder = ManagedChannelBuilder</span><br><span class="line">			.forTarget(target)</span><br><span class="line">			.nameResolverFactory(factory)</span><br><span class="line">			.defaultLoadBalancingPolicy(&quot;random&quot;)</span><br><span class="line">			.usePlaintext();</span><br><span class="line">	channel = channelBuilder.build();</span><br><span class="line">	blockingStub = GreetingGrpc.newBlockingStub(channel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://github.com/LiuMenghan/grpc-example" target="_blank" rel="noopener">示例代码</a></li>
<li><a href="https://github.com/grpc/grpc-java" target="_blank" rel="noopener">grpc-java源码地址</a></li>
<li><a href="https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md" target="_blank" rel="noopener">gRPC传输格式说明</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liumenghan.github.io/2019/10/07/grpc-in-depth/" data-id="ck1gef5xw0000capv8tvqai0n" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/10/07/grpc-in-depth/">gRPC客户端详解</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>