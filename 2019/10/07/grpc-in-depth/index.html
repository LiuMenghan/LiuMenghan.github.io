<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>gRPC客户端详解 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="RPC框架的选择常见的RPC框架主要分为轻重两种。较轻的框架一般只负责通信，如rmi、webservice、restful、Thrift、gRPC等。较重的框架一般包括完整的服务发现、负载均衡策略等等如BAT三家的Dubbo、brpc、Tars之类。 框架选择时个人认为首先要考虑的是框架的历史和项目的活跃程度。一个历史悠久的活跃项目（大概至少可以保证每两到三个月有一次小版本的更新）可以保证各种bu">
<meta property="og:type" content="article">
<meta property="og:title" content="gRPC客户端详解">
<meta property="og:url" content="http://liumenghan.github.io/2019/10/07/grpc-in-depth/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="RPC框架的选择常见的RPC框架主要分为轻重两种。较轻的框架一般只负责通信，如rmi、webservice、restful、Thrift、gRPC等。较重的框架一般包括完整的服务发现、负载均衡策略等等如BAT三家的Dubbo、brpc、Tars之类。 框架选择时个人认为首先要考虑的是框架的历史和项目的活跃程度。一个历史悠久的活跃项目（大概至少可以保证每两到三个月有一次小版本的更新）可以保证各种bu">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://liumenghan.github.io/.io//starter-genenate-grpc.png">
<meta property="og:updated_time" content="2019-10-07T11:24:06.161Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="gRPC客户端详解">
<meta name="twitter:description" content="RPC框架的选择常见的RPC框架主要分为轻重两种。较轻的框架一般只负责通信，如rmi、webservice、restful、Thrift、gRPC等。较重的框架一般包括完整的服务发现、负载均衡策略等等如BAT三家的Dubbo、brpc、Tars之类。 框架选择时个人认为首先要考虑的是框架的历史和项目的活跃程度。一个历史悠久的活跃项目（大概至少可以保证每两到三个月有一次小版本的更新）可以保证各种bu">
<meta name="twitter:image" content="http://liumenghan.github.io/.io//starter-genenate-grpc.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://liumenghan.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-grpc-in-depth" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/10/07/grpc-in-depth/" class="article-date">
  <time datetime="2019-10-07T11:24:06.161Z" itemprop="datePublished">2019-10-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      gRPC客户端详解
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="RPC框架的选择"><a href="#RPC框架的选择" class="headerlink" title="RPC框架的选择"></a>RPC框架的选择</h1><p>常见的RPC框架主要分为轻重两种。较轻的框架一般只负责通信，如rmi、webservice、restful、Thrift、gRPC等。较重的框架一般包括完整的服务发现、负载均衡策略等等如BAT三家的Dubbo、brpc、Tars之类。</p>
<p>框架选择时个人认为首先要考虑的是框架的历史和项目的活跃程度。一个历史悠久的活跃项目（大概至少可以保证每两到三个月有一次小版本的更新）可以保证各种bug早已暴露并修复，让我们可以更专注于我们自己的项目本身，而不是要担心究竟是我们自己的代码有问题还是框架本身就有问题。</p>
<p>重量级RPC框架有一个主要问题就是结构复杂，另外主语言之外的代码质量也不太容易保证。个人认为活跃的社区以及一个活跃的开源管理团队是这些重型RPC框架项目成功的必要前提条件。比如我们项目组试用过腾讯的Tars，C++同学表示没有任何问题，然后JAVA同学表示java版本的各种bug，提的pull request两个多月才有反馈，官方jar包将近两年没有更新过。</p>
<p>轻量级rpc框架中，restful可以被视作标杆。由于restful基于http协议，天然被各种框架支持，而且非常灵活。restful的缺点有两方面，一是过于灵活，缺少根据协议生成服务端和客户端代码的工具，联调往往要花更多的时间；二是大部分序列化基于json或者xml，相对来讲效率不理想。和restful相比，其它很多轻量级框架都有这样或者那样的缺点，有的缺少跨语言支持（rmi），有的既繁琐又缺乏效率优势（webservice）。个人认为其中相对理想的是gRPC和Thrift。</p>
<h2 id="gRPC简介"><a href="#gRPC简介" class="headerlink" title="gRPC简介"></a>gRPC简介</h2><p>Protobuf是一种google推出的非常流行的跨语言序列化/反序列化框架。在Protobuf2中就已经出现了用rpc定义服务的概念，但是一直缺少一种流行的rpc框架支持。当Http2推出之后，google将Http2和protobuf3结合，推出了gRPC。gRPC继承了Protobuf和Http2的优点，包括：</p>
<ul>
<li>序列化反序列化性能好</li>
<li>强类型支持</li>
<li>向前/向后兼容</li>
<li>有代码生成机制，而且可以支持多语言</li>
<li>长连接、多路复用</li>
</ul>
<p>同时gRPC还提供了简单地服务发现和负载均衡功能。虽然这并不是gRPC框架的重点，但是开发者可以非常容易的自己扩展gRPC这些功能，实现自己的策略或应用最新的相关方面技术，而不用像重型Rpc框架一样受制于框架本身是否支持。</p>
<h2 id="gRPC与Thrift对比"><a href="#gRPC与Thrift对比" class="headerlink" title="gRPC与Thrift对比"></a>gRPC与Thrift对比</h2><p>Thrift是Facebook推出的一种RPC框架，从性能上来讲远优于gRPC。但是在实际调研时发现有一个很麻烦的问题：Thrift的客户端是<strong>线程不安全</strong>的——这意味着在Spring中无法以单例形式注入到Bean中。解决方案有三种：</p>
<ol>
<li>每次调用创建一个Thrift客户端。这不仅意味着额外的对象创建和垃圾回收开销，而且实际上相当于只使用了短链接，这是一个开发复杂度最低但是从性能上来讲最差的解决方案。</li>
<li>利用Pool，稍微复杂一点的解决方案，但是也非常成熟。但是问题在于一来要实现服务发现和负载均衡恐怕需要很多额外开发；二来恐怕要创建Pool数量*服务端数量个客户端，内存开销会比较大。</li>
<li>使用异步框架如Netty，可以成功避免创建过多的客户端，但是仍要自己实现服务发现和负载均衡，相对复杂。实际上Facebook有一个基于Netty的Thrift客户端，叫Nifty，但是快四年没更新了。。。</li>
</ol>
<p>相比较而言gRPC就友好多了，本身有简单而且可扩展的服务发现和负载均衡功能，底层基于Netty所以线程安全，在不需要极限压榨性能的情况下是非常好的选择。当然如果需要极限压榨性能Thrift也未必够看。</p>
<h1 id="gRPC入门"><a href="#gRPC入门" class="headerlink" title="gRPC入门"></a>gRPC入门</h1><h2 id="gRPC服务定义"><a href="#gRPC服务定义" class="headerlink" title="gRPC服务定义"></a>gRPC服务定义</h2><p>gRPC中有一个特殊的关键字<strong>stream</strong>，表示可以以流式输入或输出多个protobuf对象。注意只有异步非阻塞的客户端支持以stream形式输入，同步阻塞客户端不支持以stream形式输入。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">syntax = &quot;proto3&quot;;  //gRPC必须使用proto3</span><br><span class="line"></span><br><span class="line">option java_multiple_files = true;</span><br><span class="line">option java_package = &quot;cn.lmh.examples.grpc.proto&quot;;</span><br><span class="line"></span><br><span class="line">service RouteGuide &#123;</span><br><span class="line">	// 输入一个坐标，返回坐标和时间(1:1)</span><br><span class="line">	rpc getPoint(Point) returns (LocationNote) &#123;&#125;</span><br><span class="line">	// 输入一个矩形，以stream形式返回一系列点(1:n)</span><br><span class="line">	rpc listPoints(Rectangle) returns (stream Point) &#123;&#125;</span><br><span class="line">	// 以stream形式输入一系列点，返回点的数量和总共花费的时间(m:1)</span><br><span class="line">	rpc recordRoute(stream Point) returns (RouteSummary) &#123;&#125;</span><br><span class="line">	// 以stream形式输入一系列点，以stream形式返回已输入点的数量和总共花费的时间(m:n)</span><br><span class="line">	rpc getPointStream(stream Point) returns (stream RouteSummary) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message Point &#123;</span><br><span class="line">	int32 latitude = 1;</span><br><span class="line">	int32 longitude = 2;</span><br><span class="line">&#125;</span><br><span class="line">message Rectangle &#123;</span><br><span class="line">	Point lo = 1;</span><br><span class="line">	Point hi = 2;</span><br><span class="line">&#125;</span><br><span class="line">message LocationNote &#123;</span><br><span class="line">	Point location = 1;</span><br><span class="line">	int64 timestamp = 2;</span><br><span class="line">&#125;</span><br><span class="line">message RouteSummary &#123;</span><br><span class="line">	int32 point_count = 1;</span><br><span class="line">	int64 elapsed_time = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="依赖和代码生成"><a href="#依赖和代码生成" class="headerlink" title="依赖和代码生成"></a>依赖和代码生成</h2><p>由于protoc的gRPC插件需要自己编译，而且存在环境问题。推荐使用gradle或者maven的protobuf插件。入门示例项目使用了gradle，根目录build.gradle配置如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">	id &apos;java&apos;</span><br><span class="line">	id &apos;idea&apos;</span><br><span class="line">	id &apos;wrapper&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ext &#123;</span><br><span class="line">	groupId = &apos;cn.lmh.leviathan&apos;</span><br><span class="line">	proto = [</span><br><span class="line">		version : &quot;3.9.0&quot;,</span><br><span class="line">		&quot;grpc&quot; :[</span><br><span class="line">			version : &quot;1.23.0&quot;</span><br><span class="line">		]</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">allprojects&#123;</span><br><span class="line">	apply plugin: &apos;java&apos;</span><br><span class="line">	apply plugin: &apos;idea&apos;</span><br><span class="line"></span><br><span class="line">	sourceCompatibility=JavaVersion.VERSION_1_8</span><br><span class="line">	targetCompatibility=JavaVersion.VERSION_1_8</span><br><span class="line"></span><br><span class="line">	project.group = &apos;cn.lmh.examples&apos;</span><br><span class="line"></span><br><span class="line">	compileJava.options.encoding = &apos;UTF-8&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">subprojects&#123;</span><br><span class="line">	repositories &#123;</span><br><span class="line">		mavenCentral()</span><br><span class="line">		mavenLocal();</span><br><span class="line">	&#125;;</span><br><span class="line">	configurations &#123;</span><br><span class="line">		compile</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dependencies &#123;</span><br><span class="line">		compile &quot;io.grpc:grpc-netty-shaded:$&#123;proto.grpc.version&#125;&quot;</span><br><span class="line">		compile &quot;io.grpc:grpc-protobuf:$&#123;proto.grpc.version&#125;&quot;</span><br><span class="line">		compile &quot;io.grpc:grpc-stub:$&#123;proto.grpc.version&#125;&quot;</span><br><span class="line"></span><br><span class="line">		testCompile group: &apos;junit&apos;, name: &apos;junit&apos;, version: &apos;4.12&apos;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子项目build.gradle如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">plugins&#123;</span><br><span class="line">	id &apos;com.google.protobuf&apos; version &apos;0.8.10&apos;	//引入protobuf插件</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sourceSets&#123;</span><br><span class="line">	main&#123;</span><br><span class="line">		proto &#123;</span><br><span class="line">			srcDir &apos;src/main/proto&apos;	//指定.proto文件所在的位置</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protobuf &#123;</span><br><span class="line">	generatedFilesBaseDir = &quot;$projectDir/src&quot;	//生成文件的根目录</span><br><span class="line"></span><br><span class="line">	protoc &#123;</span><br><span class="line">		artifact = &quot;com.google.protobuf:protoc:$&#123;proto.version&#125;&quot;	//protoc的版本</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	plugins &#123;</span><br><span class="line">		grpc &#123;</span><br><span class="line">			artifact = &quot;io.grpc:protoc-gen-grpc-java:$&#123;proto.grpc.version&#125;&quot;	//gRPC的版本</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	generateProtoTasks &#123;</span><br><span class="line">		all()*.plugins &#123;</span><br><span class="line">			grpc &#123;</span><br><span class="line">				outputSubDir = &quot;java&quot;	//grpc生成文件的子目录</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们的入门子项目名称叫做starter，配置好build.gradle之后，执行gradlew :starter:generateProto就可以在src/main/java下生成对应的文件：</p>
<p><img src="/.io//starter-genenate-grpc.png" alt="gRPC生成的目录结构"></p>
<h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><p>无论客户端以异步非阻塞还是同步阻塞形式调用，gRPC服务端的Response都是异步形式。对于异步的Request或者Response，都需要实现gRPC的<code>io.grpc.stub.StreamObserver</code>接口。<code>io.grpc.stub.StreamObserver</code>接口有三个方法：</p>
<ul>
<li><code>onNext</code>:表示接收/发送一个对象</li>
<li><code>onError</code>:处理异常</li>
<li><code>onCompleted</code>:表示Request或Response结束</li>
</ul>
<p>当Request发送到服务端端时，会异步调用requestObserver的onNext方法，直到结束时调用requestObserver的onCompleted方法；服务端调用responseObserver的onNext把Response返回给客户端，直到调用responseObserver的onCompleted方法通知客户端Response结束。服务端代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line">public class RouteGuideServer &#123;</span><br><span class="line">	private final int port;</span><br><span class="line">	private final Server server;</span><br><span class="line"></span><br><span class="line">	public RouteGuideServer(int port) throws IOException &#123;</span><br><span class="line">		this.port = port;</span><br><span class="line">		server = ServerBuilder.forPort(port).addService(new RouteGuideService())</span><br><span class="line">				.build();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Start server.</span><br><span class="line">	 */</span><br><span class="line">	public void start() throws IOException &#123;</span><br><span class="line">		server.start();</span><br><span class="line">		System.out.println(&quot;Server started, listening on &quot; + port);</span><br><span class="line">		Runtime.getRuntime().addShutdownHook(new Thread() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				RouteGuideServer.this.stop();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Stop server</span><br><span class="line">	 */</span><br><span class="line">	public void stop() &#123;</span><br><span class="line">		if (server != null) &#123;</span><br><span class="line">			server.shutdown();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Await termination on the main thread since the grpc library uses daemon threads.</span><br><span class="line">	 */</span><br><span class="line">	private void blockUntilShutdown() throws InterruptedException &#123;</span><br><span class="line">		if (server != null) &#123;</span><br><span class="line">			server.awaitTermination();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) throws Exception &#123;</span><br><span class="line">		RouteGuideServer server = new RouteGuideServer(8980);</span><br><span class="line">		server.start();</span><br><span class="line">		server.blockUntilShutdown();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private static class RouteGuideService extends RouteGuideGrpc.RouteGuideImplBase &#123;</span><br><span class="line">		@Override</span><br><span class="line">		public void getPoint(Point request, StreamObserver&lt;LocationNote&gt; responseObserver) &#123;</span><br><span class="line">			LocationNote value = LocationNote</span><br><span class="line">				.newBuilder()</span><br><span class="line">				.setLocation(request)</span><br><span class="line">				.setTimestamp(System.nanoTime())</span><br><span class="line">				.build();</span><br><span class="line">			responseObserver.onNext(value);</span><br><span class="line">			responseObserver.onCompleted();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		@Override</span><br><span class="line">		public void listPoints(Rectangle request, StreamObserver&lt;Point&gt; responseObserver) &#123;</span><br><span class="line">			int left = Math.min(request.getLo().getLongitude(), request.getHi().getLongitude());</span><br><span class="line">			int right = Math.max(request.getLo().getLongitude(), request.getHi().getLongitude());</span><br><span class="line">			int top = Math.max(request.getLo().getLatitude(), request.getHi().getLatitude());</span><br><span class="line">			int bottom = Math.max(request.getLo().getLatitude(), request.getHi().getLatitude());</span><br><span class="line">			for (int x = left; x &lt;= right; x++) &#123;</span><br><span class="line">				for (int y = top; y &gt;= bottom; y--) &#123;</span><br><span class="line">					Point point = Point.newBuilder().setLongitude(x).setLatitude(y).build();</span><br><span class="line">					responseObserver.onNext(point);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			responseObserver.onCompleted();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		@Override</span><br><span class="line">		public StreamObserver&lt;Point&gt; recordRoute(StreamObserver&lt;RouteSummary&gt; responseObserver) &#123;</span><br><span class="line">			return new StreamObserver&lt;Point&gt;() &#123; //返回的是requestObserver</span><br><span class="line">				AtomicInteger pointCount = new AtomicInteger(0);</span><br><span class="line">				final long startTime = System.nanoTime();</span><br><span class="line"></span><br><span class="line">				@Override</span><br><span class="line">				public void onNext(Point value) &#123;</span><br><span class="line">					int count = pointCount.incrementAndGet();</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				@Override</span><br><span class="line">				public void onError(Throwable t) &#123;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				@Override</span><br><span class="line">				public void onCompleted() &#123;</span><br><span class="line">					RouteSummary result = RouteSummary.newBuilder().setElapsedTime(System.nanoTime() - startTime).setPointCount(pointCount.get()).build();</span><br><span class="line">					responseObserver.onNext(result);</span><br><span class="line">					responseObserver.onCompleted();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		@Override</span><br><span class="line">		public StreamObserver&lt;Point&gt; getPointStream(StreamObserver&lt;RouteSummary&gt; responseObserver) &#123;</span><br><span class="line">			return new StreamObserver&lt;Point&gt;() &#123; //返回的是requestObserver</span><br><span class="line">				AtomicInteger pointCount = new AtomicInteger(0);</span><br><span class="line">				final long startTime = System.nanoTime();</span><br><span class="line"></span><br><span class="line">				@Override</span><br><span class="line">				public void onNext(Point value) &#123;</span><br><span class="line">					int count = pointCount.incrementAndGet();</span><br><span class="line">					RouteSummary result = RouteSummary.newBuilder().setElapsedTime(System.nanoTime() - startTime).setPointCount(count).build();</span><br><span class="line">					responseObserver.onNext(result);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				@Override</span><br><span class="line">				public void onError(Throwable t) &#123;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				@Override</span><br><span class="line">				public void onCompleted() &#123;</span><br><span class="line">					responseObserver.onCompleted();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>gRPC的客户端有同步阻塞客户端（blockingStub)和异步非阻塞客户端(Stub）两种。同步客户端使用比较方便，但是性能较低，而且不支持stream形式的Request;异步客户端性能较高，支持stream形式的Request，但是如果想要以同步方式调用需要额外封装。本文将主要以异步为例。</p>
<h3 id="异步转同步"><a href="#异步转同步" class="headerlink" title="异步转同步"></a>异步转同步</h3><p>由于gRPC的异步客户端性能较高且功能更完整，所以一般都会采用异步客户端。异步客户端接收到的Response也是以<code>io.grpc.stub.StreamObserver</code>形式。由于客户端的调用可能是在异步进程中但更可能是在同步进程中，所以就存在一个如何把gRPC异步Response转为同步Response的问题。</p>
<p>一个比较常见的思路是写一个<code>io.grpc.stub.StreamObserver</code>实现，里面有一个内置变量保存异步Response的结果，再添加一个阻塞式的<code>get()</code>方法，直到Response结束才把所有结果返回。要知道Response是否结束，需要添加一个<code>Boolean</code>或者<code>AtomicBoolean</code>变量，初始化为<code>false</code>，调用<code>responseObserver.onCompleted()</code>方法时设置为<code>true</code>，这样就可以通过这个变量判断Response是否结束。</p>
<p>阻塞<code>get()</code>方法最常见的思路是<code>get()</code>写一个<code>while</code>循环，直到变量值改为<code>true</code>才退出循环并返回结果。这种方式的优点是简单直接，任何语言都可以简单实现，缺点是由于使用循环可能CPU占用较高。而对于java这种多线程比较完善的语言，另一个比较好思路是Response结束前将线程挂起，当调用<code>responseObserver.onCompleted()</code>方法再唤醒线程。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class CallableStreamObserver&lt;T&gt; implements StreamObserver&lt;T&gt; &#123;</span><br><span class="line">	List&lt;T&gt; values = new ArrayList&lt;T&gt;();</span><br><span class="line">	boolean isCompleted = false;</span><br><span class="line">	Throwable t = null;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void onNext(T value) &#123;</span><br><span class="line">		this.values.add(value);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void onError(Throwable t) &#123;</span><br><span class="line">		this.isCompleted = true;</span><br><span class="line">		notifyAll();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public synchronized void onCompleted() &#123;</span><br><span class="line">		this.isCompleted = true;</span><br><span class="line">		notifyAll();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public List&lt;T&gt; get() throws Throwable &#123;</span><br><span class="line">		if (!this.isCompleted) &#123;</span><br><span class="line">			synchronized (this) &#123;</span><br><span class="line">				this.wait(60 * 1000);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (null != t) &#123;</span><br><span class="line">			throw this.t;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			return this.values;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="客户端代码"><a href="#客户端代码" class="headerlink" title="客户端代码"></a>客户端代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">public class RouteGuideClient &#123;</span><br><span class="line"></span><br><span class="line">    private final ManagedChannel channel;</span><br><span class="line">    private final RouteGuideGrpc.RouteGuideBlockingStub blockingStub;</span><br><span class="line">    private final RouteGuideGrpc.RouteGuideStub asyncStub;</span><br><span class="line"></span><br><span class="line">    public RouteGuideClient(String host, int port) &#123;</span><br><span class="line">        String target = &quot;dns:///&quot; + host + &quot;:&quot; + port;</span><br><span class="line">        ManagedChannelBuilder&lt;?&gt; channelBuilder = ManagedChannelBuilder</span><br><span class="line">                .forTarget(target)</span><br><span class="line">                .usePlaintext();</span><br><span class="line">        channel = channelBuilder.build();</span><br><span class="line">        blockingStub = RouteGuideGrpc.newBlockingStub(channel);</span><br><span class="line">        asyncStub = RouteGuideGrpc.newStub(channel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void shutdown() throws InterruptedException &#123;</span><br><span class="line">        channel.shutdown().awaitTermination(5, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public LocationNote getPoint(int lo, int lt, boolean blocking) throws Throwable &#123;</span><br><span class="line">        Point point = Point.newBuilder().setLongitude(lo).setLatitude(lt).build();</span><br><span class="line">        if(blocking) &#123;</span><br><span class="line">            return blockingStub.getPoint(point);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            CallableStreamObserver&lt;LocationNote&gt; responseObserver = new CallableStreamObserver&lt;LocationNote&gt;();</span><br><span class="line">            asyncStub.getPoint(point, responseObserver);</span><br><span class="line">            return responseObserver.get().get(0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Iterator&lt;Point&gt; listPoints(int left, int top, int right, int bottom, boolean blocking) throws Throwable &#123;</span><br><span class="line">        Point hi = Point.newBuilder().setLongitude(left).setLatitude(top).build();</span><br><span class="line">        Point lo = Point.newBuilder().setLongitude(right).setLatitude(bottom).build();</span><br><span class="line">        Rectangle rec = Rectangle.newBuilder().setHi(hi).setLo(lo).build();</span><br><span class="line">        if(blocking)&#123;</span><br><span class="line">            return blockingStub.listPoints(rec);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            CallableStreamObserver&lt;Point&gt; responseObserver = new CallableStreamObserver&lt;Point&gt;();</span><br><span class="line">            asyncStub.listPoints(rec, responseObserver);</span><br><span class="line">            return responseObserver.get().iterator();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public RouteSummary recordRoute(Collection&lt;Point&gt; points) throws Throwable &#123;</span><br><span class="line">        CallableStreamObserver&lt;RouteSummary&gt; responseObserver = new CallableStreamObserver&lt;RouteSummary&gt;();</span><br><span class="line">        StreamObserver&lt;Point&gt; requestObserver = asyncStub.recordRoute(responseObserver);</span><br><span class="line">        points.stream().parallel().forEach(p -&gt; requestObserver.onNext(p));</span><br><span class="line">        requestObserver.onCompleted();</span><br><span class="line">        return responseObserver.get().get(0);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List&lt;RouteSummary&gt; getPointStream(Collection&lt;Point&gt; points) throws Throwable &#123;</span><br><span class="line">        CallableStreamObserver&lt;RouteSummary&gt; responseObserver = new CallableStreamObserver&lt;RouteSummary&gt;();</span><br><span class="line">        StreamObserver&lt;Point&gt; requestObserver = asyncStub.getPointStream(responseObserver);</span><br><span class="line">        points.stream().parallel().forEach(p -&gt; requestObserver.onNext(p));</span><br><span class="line">        requestObserver.onCompleted();</span><br><span class="line">        return responseObserver.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="gRPC客户端代码详解"><a href="#gRPC客户端代码详解" class="headerlink" title="gRPC客户端代码详解"></a>gRPC客户端代码详解</h1><p>gRPC官方将自己分为三层组件：Stub、Channel和Transport。</p>
<ul>
<li>Stub层是最上层的代码，gRPC附带的插件可以从.proto文件直接生成Stub层代码，开发人员通过直接调用Stub层的代码调用RPC服务</li>
<li>Channel层是对Transport层功能的抽象，同时提供了很多有用的功能，比如服务发现和负载均衡。。</li>
<li>Transport层承担了将字节从网络中取出和放入数据的工作，有三种实现Netty、okHttp、inProgress。Transport层是最底层的代码。</li>
</ul>
<p>整个grpc-java项目的代码比较多。从风格上来讲，封装比较多，相对于interface更喜欢使用abstract class，相对于反射更喜欢使用硬编码，而且大量使用了单线程异步调用造成调用栈断裂，与常见的java项目的编码风格有很大差别，阅读起来可能容易不习惯。</p>
<p>在源码层面本文将关注下面这些方面：</p>
<ul>
<li>Channel的初始化过程;</li>
<li>gRPC中的服务发现;</li>
<li>gRPC中的负载均衡</li>
<li>Client与Server之间的数据传输</li>
</ul>
<h2 id="Channel的初始化过程"><a href="#Channel的初始化过程" class="headerlink" title="Channel的初始化过程"></a>Channel的初始化过程</h2><p>通过入门示例可以看到，Channel的初始化过程分三步：</p>
<ol>
<li>调用forTarget方法创建<code>io.grpc.ManagedChannelBuilder</code>;</li>
<li>配置各种选项，不论如何配置，返回的总是<code>io.grpc.ManagedChannelBuilder</code>对象;</li>
<li>调用build方法创建<code>io.grpc.ManagedChannel</code>。</li>
</ol>
<h3 id="forTarget方法"><a href="#forTarget方法" class="headerlink" title="forTarget方法"></a><code>forTarget</code>方法</h3><p>gRPC这里设计比较繁琐，过程比较绕。<code>forTarget</code>方法的实际功能就是<strong>把参数target赋值给<code>io.grpc.ManagedChannelBuilder</code>的内部变量<code>target</code></strong>，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static ManagedChannelBuilder&lt;?&gt; forTarget(String target) &#123;</span><br><span class="line">	return ManagedChannelProvider.provider().builderForTarget(target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>io.grpc.ManagedChannelProvider.provider()</code>会返回一个<code>io.grpc.ManagedChannelProvider</code>实现。有哪些<code>io.grpc.ManagedChannelProvider</code>实现是在<code>io.grpc.ManagedChannelProvider</code>中以硬编码形式确定的，这里其实存在利用反射改进的空间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private static final class HardcodedClasses implements Iterable&lt;Class&lt;?&gt;&gt; &#123;</span><br><span class="line">	@Override</span><br><span class="line">	public Iterator&lt;Class&lt;?&gt;&gt; iterator() &#123;</span><br><span class="line">		List&lt;Class&lt;?&gt;&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">		try &#123;</span><br><span class="line">			list.add(Class.forName(&quot;io.grpc.okhttp.OkHttpChannelProvider&quot;));</span><br><span class="line">		&#125; catch (ClassNotFoundException ex) &#123;</span><br><span class="line">			// ignore</span><br><span class="line">		&#125;</span><br><span class="line">		try &#123;</span><br><span class="line">			list.add(Class.forName(&quot;io.grpc.netty.NettyChannelProvider&quot;));</span><br><span class="line">		&#125; catch (ClassNotFoundException ex) &#123;</span><br><span class="line">		// ignore</span><br><span class="line">		&#125;</span><br><span class="line">		return list.iterator();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上就根据依赖的jar包不同就只有两个实现，一个netty的，一个okhttp的。如果像前面示例项目一样只配置了netty实现,那就只有netty的。<code>io.grpc.netty.NettyChannelProvider</code>的buildForTarget方法调用的是<code>io.grpc.netty.NettyChannelBuilder</code>的<code>forTarget</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public NettyChannelBuilder builderForTarget(String target) &#123;</span><br><span class="line">	return NettyChannelBuilder.forTarget(target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而<code>io.grpc.netty.NettyChannelBuilder</code>继承自<code>io.grpc.internal.AbstractManagedChannelImplBuilder</code>，<code>forTarget</code>方法实际上调用了父类的构造函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NettyChannelBuilder(String target) &#123;</span><br><span class="line">	super(target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static NettyChannelBuilder forTarget(String target) &#123;</span><br><span class="line">	return new NettyChannelBuilder(target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>io.grpc.internal.AbstractManagedChannelImplBuilder</code>的构造函数主要作用是把参数赋值给<code>target</code>变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protected AbstractManagedChannelImplBuilder(String target) &#123;</span><br><span class="line">	this.target = Preconditions.checkNotNull(target, &quot;target&quot;);</span><br><span class="line">	this.directServerAddress = null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="build方法"><a href="#build方法" class="headerlink" title="build方法"></a><code>build</code>方法</h3><p>从前文可以看到，实际初始化的<code>io.grpc.ManagedChannelBuilder</code>实际上是<code>io.grpc.netty.NettyChannelBuilder</code>，其的<code>build</code>方法实现在其父类<code>io.grpc.internal.AbstractManagedChannelImplBuilder</code>中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public ManagedChannel build() &#123;</span><br><span class="line">	return new ManagedChannelOrphanWrapper(new ManagedChannelImpl(</span><br><span class="line">		this,</span><br><span class="line">		buildTransportFactory(),</span><br><span class="line">		// TODO(carl-mastrangelo): Allow clients to pass this in</span><br><span class="line">		new ExponentialBackoffPolicy.Provider(),</span><br><span class="line">		SharedResourcePool.forResource(GrpcUtil.SHARED_CHANNEL_EXECUTOR),</span><br><span class="line">		GrpcUtil.STOPWATCH_SUPPLIER,</span><br><span class="line">		getEffectiveInterceptors(),</span><br><span class="line">		TimeProvider.SYSTEM_TIME_PROVIDER));</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">`io.grpc.internal.ManagedChannelOrphanWrapper`和`io.grpc.internal.ManagedChannelImpl`其实都是`io.grpc.ManagedChannel`的实现。`io.grpc.internal.ManagedChannelOrphanWrapper`从功能上分析没有任何作用，`io.grpc.internal.ManagedChannelOrphanWrapper`会为`io.grpc.ManagedChannel`创建弱引用，并被放置到ReferenceQueue中。如果Channel是单例的，那么意义不大；如果客户端被重复创建却没有被关闭，那么ReferenceQueue中会留下相应的引用记录，可能有助于排查问题。</span><br><span class="line"></span><br><span class="line">`io.grpc.internal.ManagedChannelImpl`构造方法的几个参数中，除了第一个参数是builder本身，第二个参数是用来创建Transport的Factory，第三个参数是后台连接重试策略，第四个参数是gRPC的全局线程池，第五个和第七个都是和时间相关的对象，主要用于日志中，第六个是客户端调用时的interceptor。在`io.grpc.netty.NettyChannelBuilder`中，`buildTransportFactory`方法会创建一个`io.grpc.netty.NettyChannelBuilder.NettyTransportFactory`。</span><br><span class="line"></span><br><span class="line">## 服务发现</span><br><span class="line"></span><br><span class="line">前文的入门示例中直接写了target，只能连接单个Server。如果有多个可以提供服务的Server，那么就需要有一种方式通过单个target发现这些Server。在`io.grpc.ManagedChannelBuilder`中有一个`nameResolverFactory`方法，可以用来指定如何解析`target`地址，发现多个服务端。</span><br><span class="line"></span><br><span class="line">### `nameResolverFactory`方法</span><br><span class="line"></span><br><span class="line">这个方法的实现也在`io.grpc.internal.AbstractManagedChannelImplBuilder`中，如果用户有自己的`io.grpc.NameResolver.Factory`实现的话通过`nameResolverFactory`,gRPC就会使用用户自己的`io.grpc.NameResolver.Factroy`实现代替gRPC自己的默认实现，否则会使用`io.grpc.NameResolverRegistry`中的默认实现。</span><br><span class="line"></span><br><span class="line">`io.grpc.NameResolverRegistry`会通过硬编码加载`io.grpc.NameResolverProvider`实现，并创建一个与之有关的`io.grpc.NameResolver.Factory`的实现。目前硬编码加载的`io.grpc.NameResolverProvider`实现只有`io.grpc.internal.DnsNameResolverProvider`一种。</span><br></pre></td></tr></table></figure>

<p>private final NameResolver.Factory factory = new NameResolverFactory();<br>@GuardedBy(“this”)<br>private final LinkedHashSet<nameresolverprovider> allProviders = new LinkedHashSet&lt;&gt;();</nameresolverprovider></p>
<p>private synchronized void addProvider(NameResolverProvider provider) {<br>    checkArgument(provider.isAvailable(), “isAvailable() returned false”);<br>    allProviders.add(provider);<br>}</p>
<p>public static synchronized NameResolverRegistry getDefaultRegistry() {<br>    if (instance == null) {<br>        List<nameresolverprovider> providerList = ServiceProviders.loadAll(<br>            NameResolverProvider.class,<br>            getHardCodedClasses(),<br>            NameResolverProvider.class.getClassLoader(),<br>            new NameResolverPriorityAccessor());<br>        if (providerList.isEmpty()) {<br>            logger.warning(“No NameResolverProviders found via ServiceLoader, including for DNS. This “<br>            + “is probably due to a broken build. If using ProGuard, check your configuration”);<br>        }<br>        instance = new NameResolverRegistry();<br>        for (NameResolverProvider provider : providerList) {<br>            logger.fine(“Service loader found “ + provider);<br>            if (provider.isAvailable()) {<br>                instance.addProvider(provider);<br>            }<br>        }<br>        instance.refreshProviders();<br>    }<br>    return instance;<br>}  </nameresolverprovider></p>
<p>public NameResolver.Factory asFactory() {<br>    return factory;<br>}</p>
<p>@VisibleForTesting<br>static List&lt;Class<?>> getHardCodedClasses() {
    ArrayList<class<?>&gt; list = new ArrayList&lt;&gt;();<br>    try {<br>        list.add(Class.forName(“io.grpc.internal.DnsNameResolverProvider”));<br>    } catch (ClassNotFoundException e) {<br>        logger.log(Level.FINE, “Unable to find DNS NameResolver”, e);<br>    }<br>    return Collections.unmodifiableList(list);<br>}</class<?></p>
<p>private final class NameResolverFactory extends NameResolver.Factory {<br>    @Override<br>    @Nullable<br>    public NameResolver newNameResolver(URI targetUri, NameResolver.Args args) {<br>        List<nameresolverprovider> providers = providers();<br>        for (NameResolverProvider provider : providers) {<br>            NameResolver resolver = provider.newNameResolver(targetUri, args);<br>            if (resolver != null) {<br>                return resolver;<br>            }<br>        }<br>        return null;<br>    }</nameresolverprovider></p>
<pre><code>@Override
public String getDefaultScheme() {
    List&lt;NameResolverProvider&gt; providers = providers();
    if (providers.isEmpty()) {
        return &quot;unknown&quot;;
    }
    return providers.get(0).getDefaultScheme();
}</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">`getDefaultSchema`会匹配`target`中的schema（如http），如果匹配的上，就使用相应的`NameResolver.Factory`，返回`NameResolver`决定真正的服务访问地址。</span><br><span class="line"></span><br><span class="line">### `io.grpc.NameResolver`</span><br><span class="line"></span><br><span class="line">我们来看`io.grpc.NameResolver`</span><br></pre></td></tr></table></figure>

<p>public abstract class NameResolver {</p>
<pre><code>public abstract String getServiceAuthority();

public void start(final Listener listener) {
if (listener instanceof Listener2) {
        start((Listener2) listener);
    } else {
        start(new Listener2() {
            @Override
            public void onError(Status error) {
            listener.onError(error);
            }

            @Override
            public void onResult(ResolutionResult resolutionResult) {
                listener.onAddresses(resolutionResult.getAddresses(), resolutionResult.getAttributes());
            }
        });
    }
}

public void start(Listener2 listener) {
    start((Listener) listener);
}

public abstract void shutdown();

public void refresh() {}

@ThreadSafe
public interface Listener {

    void onAddresses(List&lt;EquivalentAddressGroup&gt; servers, @ResolutionResultAttr Attributes attributes);

    void onError(Status error);
}

public abstract static class Listener2 implements Listener {

    @Override
    public final void onAddresses(
        List&lt;EquivalentAddressGroup&gt; servers, @ResolutionResultAttr Attributes attributes) {
        onResult(
        ResolutionResult.newBuilder().setAddresses(servers).setAttributes(attributes).build());
    }

    public abstract void onResult(ResolutionResult resolutionResult);

    @Override
    public abstract void onError(Status error);
}

public static final class ResolutionResult {
    private final List&lt;EquivalentAddressGroup&gt; addresses;
    @ResolutionResultAttr
    private final Attributes attributes;
    @Nullable
    private final ConfigOrError serviceConfig;

    ResolutionResult(
        List&lt;EquivalentAddressGroup&gt; addresses,
        @ResolutionResultAttr Attributes attributes,
        ConfigOrError serviceConfig) {
        this.addresses = Collections.unmodifiableList(new ArrayList&lt;&gt;(addresses));
        this.attributes = checkNotNull(attributes, &quot;attributes&quot;);
        this.serviceConfig = serviceConfig;
    }

    public static Builder newBuilder() {
      return new Builder();
    }

    public Builder toBuilder() {
      return newBuilder()
          .setAddresses(addresses)
          .setAttributes(attributes)
          .setServiceConfig(serviceConfig);
    }

    public List&lt;EquivalentAddressGroup&gt; getAddresses() {
      return addresses;
    }

    @ResolutionResultAttr
    public Attributes getAttributes() {
      return attributes;
    }

    @Nullable
    public ConfigOrError getServiceConfig() {
      return serviceConfig;
    }

    @ExperimentalApi(&quot;https://github.com/grpc/grpc-java/issues/1770&quot;)
    public static final class Builder {
        private List&lt;EquivalentAddressGroup&gt; addresses = Collections.emptyList();
        private Attributes attributes = Attributes.EMPTY;
        @Nullable
        private ConfigOrError serviceConfig;
        Builder() {}

        public Builder setAddresses(List&lt;EquivalentAddressGroup&gt; addresses) {
            this.addresses = addresses;
            return this;
        }

        public Builder setAttributes(Attributes attributes) {
            this.attributes = attributes;
            return this;
        }

        public Builder setServiceConfig(@Nullable ConfigOrError serviceConfig) {
            this.serviceConfig = serviceConfig;
            return this;
        }

        public ResolutionResult build() {
            return new ResolutionResult(addresses, attributes, serviceConfig);
        }
    }
}</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在客户端首次连接服务端的时候会调用`Listener2`的`start`方法，需要更新的时候会调用`refresh`方法。`Listener2`可以接收服务端地址，用来返回真实的服务地址。</span><br><span class="line"></span><br><span class="line">### `io.grpc.internal.DnsNameResolver`</span><br><span class="line"></span><br><span class="line">由于gRPC支持长连接，所以如果直连的话只会访问一个域名下的一台服务器，即首次连接时通过DNS返回IP地址。`io.grpc.internal.DnsNameResolverProvider`是对`io.grpc.internal.DnsNameResolver`的简单封装，只支持以`dns://`开头的地址。`io.grpc.internal.DnsNameResolver`会根据`target`获取该host下所有关联的IP，即通过DNS解析出所有的服务端IP地址。</span><br></pre></td></tr></table></figure>

<p>public final class DnsNameResolverProvider extends NameResolverProvider {</p>
<p>  private static final String SCHEME = “dns”;</p>
<p>  @Override<br>  public DnsNameResolver newNameResolver(URI targetUri, NameResolver.Args args) {<br>    if (SCHEME.equals(targetUri.getScheme())) {<br>      String targetPath = Preconditions.checkNotNull(targetUri.getPath(), “targetPath”);<br>      Preconditions.checkArgument(targetPath.startsWith(“/“),<br>          “the path component (%s) of the target (%s) must start with ‘/‘“, targetPath, targetUri);<br>      String name = targetPath.substring(1);<br>      return new DnsNameResolver(<br>          targetUri.getAuthority(),<br>          name,<br>          args,<br>          GrpcUtil.SHARED_CHANNEL_EXECUTOR,<br>          Stopwatch.createUnstarted(),<br>          InternalServiceProviders.isAndroid(getClass().getClassLoader()));<br>    } else {<br>      return null;<br>    }<br>  }</p>
<p>  @Override<br>  public String getDefaultScheme() {<br>    return SCHEME;<br>  }</p>
<p>  @Override<br>  protected boolean isAvailable() {<br>    return true;<br>  }</p>
<p>  @Override<br>  protected int priority() {<br>    return 5;<br>  }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">可以看到`io.grpc.internal.DnsNameResolver`中的`start`和`refresh`方法都调用的是`resolve`方法，而`resolve`方法是使用执行了一个继承自`Runnable`的`Resolve`接口。</span><br><span class="line"></span><br><span class="line">![DnsNameResolver`](grpc-in-depth/DnsNameResolver-start.png)</span><br><span class="line"></span><br><span class="line">在有代理的情况下，`Resolve`的`resolveInternal`会根据代理返回的`ProxiedSocketAddress`创建`EquivalentAddressGroup`作为服务端列表返回，并设置空config；否则会调用`resolveAll`方法获取服务端列表，并调用`parseServiceConfig`方法设置config。`resolveAll`方法返回的`ResolutionResults`有三个变量`addresses`、`txtRecords`和`balancerAddresses`。</span><br></pre></td></tr></table></figure>

<p>@VisibleForTesting<br>static ResolutionResults resolveAll(<br>    AddressResolver addressResolver,<br>    @Nullable ResourceResolver resourceResolver,<br>    boolean requestSrvRecords,<br>    boolean requestTxtRecords,<br>    String name) {<br>    List&lt;? extends InetAddress&gt; addresses = Collections.emptyList();<br>    Exception addressesException = null;<br>    List<equivalentaddressgroup> balancerAddresses = Collections.emptyList();<br>    Exception balancerAddressesException = null;<br>    List<string> txtRecords = Collections.emptyList();<br>    Exception txtRecordsException = null;</string></equivalentaddressgroup></p>
<pre><code>try {
    addresses = addressResolver.resolveAddress(name);
} catch (Exception e) {
addressesException = e;
}
if (resourceResolver != null) {
    if (requestSrvRecords) {
        try {
            balancerAddresses =
                resourceResolver.resolveSrv(addressResolver, GRPCLB_NAME_PREFIX + name);
        } catch (Exception e) {
            balancerAddressesException = e;
        }
    }
    if (requestTxtRecords) {
        boolean balancerLookupFailedOrNotAttempted =
            !requestSrvRecords || balancerAddressesException != null;
        boolean dontResolveTxt =
            (addressesException != null) &amp;&amp; balancerLookupFailedOrNotAttempted;
        if (!dontResolveTxt) {
            try {
                txtRecords = resourceResolver.resolveTxt(SERVICE_CONFIG_NAME_PREFIX + name);
            } catch (Exception e) {
            txtRecordsException = e;
            }
        }    
    }
}
try {
    if (addressesException != null
        &amp;&amp; (balancerAddressesException != null || balancerAddresses.isEmpty())) {
        Throwables.throwIfUnchecked(addressesException);
        throw new RuntimeException(addressesException);
    }
} finally {
    if (addressesException != null) {
        logger.log(Level.FINE, &quot;Address resolution failure&quot;, addressesException);
    }
    if (balancerAddressesException != null) {
        logger.log(Level.FINE, &quot;Balancer resolution failure&quot;, balancerAddressesException);
    }
    if (txtRecordsException != null) {
        logger.log(Level.FINE, &quot;ServiceConfig resolution failure&quot;, txtRecordsException);
    }
}
return new ResolutionResults(addresses, txtRecords, balancerAddresses);</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">`addressResolver`的`resolveAddress`方法实际是调用JDK的`java.net.InetAddress`的`getAllByName`方法，即根据host通过DNS返回一系列服务端列表。`resourceResolver`根据LDAP协议获取指定命名空间下的服务端列表地址。`txtRecords`和`balancerAddresses`是和LDAP相关的参数，方法入参`requestSrvRecords`和`requestTxtRecords`的默认值都是false。由于LDAP不是特别常用，这里就不深入展开了。</span><br><span class="line"></span><br><span class="line">### `NameResolverListener`的`onResult`</span><br><span class="line"></span><br><span class="line">当`NameResolverListener`获取解析结果后会调用`onResult`方法，进而会调用`io.grpc.LoadBalancer`的`handleResolvedAddresses`方法。</span><br><span class="line">![获取解析结果后调用handleResolvedAddresses方法](grpc-in-depth/call-handle-resolved-response.png)</span><br><span class="line"></span><br><span class="line">## 负载均衡</span><br><span class="line"></span><br><span class="line">`io.grpc.ManagedChannel`初始化的时候可以通过`defaultLoadBalancingPolicy`方法指定负载均衡策略，实际是根据`defaultLoadBalancingPolicy`创建了一个`io.grpc.internal.AutoConfiguredLoadBalancerFactory`对象。`io.grpc.internal.AutoConfiguredLoadBalancerFactory`则通过`io.grpc.LoadBalancerRegistry`获取对应名称的负载均衡策略。`io.grpc.LoadBalancerProvider`的`getPolicyName`方法指定负载均衡策略名称，`newLoadBalancer`返回负载均衡`io.grpc.LoadBalancer`的具体实现。如果想要添加自定义负载均衡策略，需要调用`io.grpc.LoadBalancerRegistry`的`registry`方法，并自己实现`io.grpc.LoadBalancerProvider`和`io.grpc.LoadBalancer`，并指定负载均衡策略名称即可。</span><br><span class="line">![defaultLoadBalancingPolicy方法](grpc-in-depth/defaultLoadBalancingPolicy.png)</span><br><span class="line"></span><br><span class="line">### `io.grpc.LoadBalancer.SubchannelPicker`</span><br><span class="line"></span><br><span class="line">`io.grpc.LoadBalancer`的核心逻辑实际在`SubchannelPicker`中。`pickSubchannel`方法会返回的PickResult中包含真正可用的subchannel，用来进行后续的数据传输。</span><br><span class="line"></span><br><span class="line">gRPC默认提供了两种负载均衡实现策略：`prick_first`和`round_robin`。前者总会使用第一个可用的服务端，后者则是简单轮询。</span><br></pre></td></tr></table></figure>

<p>public abstract static class SubchannelPicker {<br>    /**<br>    * Make a balancing decision for a new RPC.<br>    *<br>    * @param args the pick arguments<br>    * @since 1.3.0<br>    */<br>    public abstract PickResult pickSubchannel(PickSubchannelArgs args);<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">### `handleResolvedAddresses`</span><br><span class="line"></span><br><span class="line">当服务端列表更新时，会调用`io.grpc.LoadBalancer`的`handleResolvedAddresses`方法更新可用的subchannel。</span><br></pre></td></tr></table></figure>

<p>@Override<br>public void handleResolvedAddresses(ResolvedAddresses resolvedAddresses) {<br>    List<equivalentaddressgroup> servers = resolvedAddresses.getAddresses();<br>    if (subchannel == null) {<br>        final Subchannel subchannel = helper.createSubchannel(<br>        CreateSubchannelArgs.newBuilder()<br>            .setAddresses(servers)<br>            .build());<br>        subchannel.start(new SubchannelStateListener() {<br>            @Override<br>            public void onSubchannelState(ConnectivityStateInfo stateInfo) {<br>                processSubchannelState(subchannel, stateInfo);<br>            }<br>        });<br>        this.subchannel = subchannel;<br>        helper.updateBalancingState(CONNECTING, new Picker(PickResult.withSubchannel(subchannel)));<br>        subchannel.requestConnection();<br>    } else {<br>        subchannel.updateAddresses(servers);<br>    }<br>}</equivalentaddressgroup></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">如果是首次调用(subchannel == null) 会创建subchannel，其实现是`io.grpc.internal.ManagedChannelImpl.SubchannelImpl`，创建的过程中会创建`io.grpc.internal.InternalSubchannel`。然后调用`io.grpc.internal.ManagedChannelImpl`的`updateBalancingState`方法，把`subchannelPicker`更新为实现`Picker`，然后开启subchannel的连接。</span><br><span class="line"></span><br><span class="line">![开启subchannel链接](grpc-in-depth/start-subchannel.png)</span><br><span class="line"></span><br><span class="line">在开启subchannel的连接过程中，会调用`io.grpc.internal.InternalSubchannel`的`obtainActiveTransport`方法。</span><br><span class="line"></span><br><span class="line">这里的transportFactory就是上面提到`io.grpc.ManagedChannelBuilder`调用`build`初始化时调用`buildTransportFactory`方法返回的，依赖于Transport层的具体实现。在netty实现中，返回的是`io.grpc.netty.NettyClientTransport`。</span><br><span class="line"></span><br><span class="line">## 传输</span><br><span class="line"></span><br><span class="line">gRPC客户端发起Request时，stub会调用`ClientCalls`的`startCall`方法，最终会调用`io.grpc.internal.ManagedChannelImpl.ChannelTransportProvider`的`get`方法获取`io.grc.internal.ClientTransport`。</span><br><span class="line"></span><br><span class="line">![gRPC客户端发起Request时调用ChannelTransportProvider的get方法](grpc-in-depth/start-call.png)</span><br></pre></td></tr></table></figure>

<p>public ClientTransport get(PickSubchannelArgs args) {<br>SubchannelPicker pickerCopy = subchannelPicker;<br>    if (shutdown.get()) {<br>        return delayedTransport;<br>    }<br>    if (pickerCopy == null) {<br>        final class ExitIdleModeForTransport implements Runnable {<br>            @Override<br>            public void run() {<br>                exitIdleMode();<br>            }<br>        }<br>        syncContext.execute(new ExitIdleModeForTransport());<br>        return delayedTransport;<br>    }<br>    PickResult pickResult = pickerCopy.pickSubchannel(args);<br>    ClientTransport transport = GrpcUtil.getTransportFromPickResult(<br>        pickResult, args.getCallOptions().isWaitForReady());<br>    if (transport != null) {<br>        return transport;<br>    }<br>    return delayedTransport;<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">如果subchannelPicker存在，会使用subchannelPicker进行选择；如果是首次访问服务端时subchannel肯定不存在，会使用syncContext异步执行`exitIdleMode`方法初始化。syncContext是一个**单线程执行队列，可以保证先提交的任务先执行**。delayedTransport的执行也依赖于syncContext，这就保证了delayedTransport中的方法执行一定会在`exitIdleMode`方法之后。</span><br><span class="line"></span><br><span class="line">### 首次访问服务端时执行`exidIdleMode`方法</span><br><span class="line"></span><br><span class="line">`exitIdleMode`方法会初始化`NameResolver`和`LoadBalancer`，并会启动`NameResolverListener`。当解析完成后会调用`NameResolverListener`的`onResult`方法，进而调用`LoadBalancer`的`handleResolvedAddresses`方法创建subchannelPicker、创建并连接subchannel。</span><br></pre></td></tr></table></figure>

<p>@VisibleForTesting<br>void exitIdleMode() {<br>    syncContext.throwIfNotInThisSynchronizationContext();<br>    if (shutdown.get() || panicMode) {<br>        return;<br>    }<br>    if (inUseStateAggregator.isInUse()) {<br>        cancelIdleTimer(false);<br>    } else {<br>        rescheduleIdleTimer();<br>    }<br>    if (lbHelper != null) {<br>        return;<br>    }<br>    channelLogger.log(ChannelLogLevel.INFO, “Exiting idle mode”);<br>    LbHelperImpl lbHelper = new LbHelperImpl();<br>    lbHelper.lb = loadBalancerFactory.newLoadBalancer(lbHelper);<br>    this.lbHelper = lbHelper;</p>
<pre><code>NameResolverListener listener = new NameResolverListener(lbHelper, nameResolver);
nameResolver.start(listener);
nameResolverStarted = true;</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### Request</span><br><span class="line"></span><br><span class="line">发送Request时会调用`ConnectionClientTransport`的`newStream`方法返回一个`io.grpc.internal.ClientStream`对象,而首次调用会通过delayedTransport延迟调用`newStream`方法。netty实现会返回一个`io.grpc.netty.shaded.io.grpc.netty.NettyClientStream`对象。`io.grpc.internal.ClientStream`下有两个子类,`TransportState`负责处理传输状态，`Sink`负责写入数据。</span><br><span class="line"></span><br><span class="line">![调用newStream的调用栈](grpc-in-depth/calling-new-stream.png)</span><br><span class="line"></span><br><span class="line">在进行一系列http2设置后，会调用`io.grpc.internal.ClientStream`的`start`方法，为`TransportState`设置监听并通过`Sink`写入Header。</span><br></pre></td></tr></table></figure>

<p>@Override<br>public final void start(ClientStreamListener listener) {<br>    transportState().setListener(listener);<br>    if (!useGet) {<br>        abstractClientStreamSink().writeHeaders(headers, null);<br>        headers = null;<br>    }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">初始化结束后，调用requestObserver的`onNext`方法会调用`io.grpc.internal.ClientCallImpl`的`sendMessage`方法，将protobuf对象转换成`InputStream`，并作为参数调用`io.grpc.internal.ClientStream`的`writeMessage`方法，进而调用`io.grpc.internal.MessageFramer`的`writePayload`方法，最终调用`writeToOutputStream`方法将内容写入Http的OutputStream。如果是参数是stream形式会继续调用flush。</span><br><span class="line"></span><br><span class="line">![onNext](grpc-in-depth/request-on-next.png)</span><br><span class="line"></span><br><span class="line">调用requestObserver的`onCompleted`方法会调用`io.grpc.internal.ClientCallImpl`的`halfClose`方法，进而会调用`io.grpc.internal.MessageFramer`的`endOfMessages`，flush并结束发送消息。</span><br><span class="line"></span><br><span class="line">![onComplete](grpc-in-depth/request-on-complete.png)</span><br><span class="line"></span><br><span class="line">### Response</span><br><span class="line"></span><br><span class="line">![onNext](grpc-in-depth/response-on-next.png)</span><br><span class="line"></span><br><span class="line">客户端接受到Response会调用ClientStreamListener的`messagesAvailable`方法，并通过同步线程池最终调用StreamObserver的`onNext`方法接收数据。</span><br><span class="line"></span><br><span class="line">![onComplete](grpc-in-depth/response-on-complete.png)</span><br><span class="line"></span><br><span class="line">当返回结束时会调用TransportState的`transportReportStatus`方法关闭请求，进而调用ClientStreamListener的`closed`方法关闭监听，进而调用StreamObserver的`onClose`方法。</span><br><span class="line"></span><br><span class="line">### gRPC通信格式</span><br><span class="line"></span><br><span class="line">gRPC发送的请求发送方法是POST，路径是/$&#123;serviceName&#125;/$&#123;methodName&#125;,content-type为content-type = application/grpc+proto。</span><br><span class="line"></span><br><span class="line">#### Request</span><br></pre></td></tr></table></figure>

<p>HEADERS (flags = END_HEADERS)<br>:method = POST<br>:scheme = http<br>:path = /RouteGuide/getPoint<br>grpc-timeout = 1S<br>content-type = application/grpc+proto<br>grpc-encoding = gzip</p>
<p>DATA (flags = END_STREAM)<br><length-prefixed message></length-prefixed></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#### Response</span><br></pre></td></tr></table></figure>

<p>HEADERS (flags = END_HEADERS)<br>:status = 200<br>grpc-encoding = gzip<br>content-type = application/grpc+proto</p>
<p>DATA<br><length-prefixed message></length-prefixed></p>
<p>HEADERS (flags = END_STREAM, END_HEADERS)<br>grpc-status = 0 # OK<br>trace-proto-bin = jher831yy13JHy3hc</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 扩展gRPC</span><br><span class="line"></span><br><span class="line">### 自定义基于zookeeper的`NameResolver.Factory`实现</span><br></pre></td></tr></table></figure>

<p>public class CuratorNameResolver extends NameResolver {<br>    CuratorFramework curatorFramework;<br>    String basePath;<br>    String serviceAuthority;<br>    private Listener2 listener;</p>
<pre><code>public CuratorNameResolver(CuratorFramework curatorFramework, String basePath, String serviceAuthority) {
    this.curatorFramework = curatorFramework;
    this.basePath = basePath;
    this.serviceAuthority = serviceAuthority;
}

@Override
public void start(Listener2 listener) {
    this.curatorFramework.start();
    this.listener = listener;
    refresh();
}

@Override
public void refresh() {
    List&lt;EquivalentAddressGroup&gt; servers = new ArrayList&lt;&gt;();
    try {
        List&lt;EquivalentAddressGroup&gt; addresses = curatorFramework.getChildren()
                .forPath(basePath)
                .stream().map(address -&gt;{
                    try {
                        URI uri = new URI(&quot;http://&quot; + address);
                        return new EquivalentAddressGroup(
                            new InetSocketAddress(uri.getHost(), uri.getPort()));
                    }catch (Exception e){
                        listener.onError(Status.INTERNAL);
                        return null;
                    }
                }).collect(Collectors.toList());
        listener.onResult(ResolutionResult.newBuilder().setAddresses(addresses).build());

    } catch (Exception e) {
        listener.onError(Status.INTERNAL);
    }
}

@Override
public String getServiceAuthority() {
    return this.serviceAuthority;
}

@Override
public void shutdown() {
    this.curatorFramework.close();
}

public static class Factory extends NameResolver.Factory{
    @Override
    public NameResolver newNameResolver(URI targetUri, Args args) {
        String address = targetUri.getHost() + &quot;:&quot; + targetUri.getPort();
        String authority = null == targetUri.getAuthority() ? address : targetUri.getAuthority();
        CuratorFramework curator = CuratorFrameworkFactory.builder()
                .connectString(address)
                .retryPolicy(new ExponentialBackoffRetry(1000, 5))
                .connectionTimeoutMs(1000)
                .sessionTimeoutMs(60000)
                .build();
        return new CuratorNameResolver(curator, targetUri.getPath(), authority);
    }

    @Override
    public String getDefaultScheme() {
        return &quot;zookeeper&quot;;
    }
}</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">### 自定义随机负载均衡实现</span><br></pre></td></tr></table></figure>

<p>public class RandomLoadBalancer extends LoadBalancer{<br>    LoadBalancer.Helper helper;</p>
<pre><code>private final Map&lt;EquivalentAddressGroup, Subchannel&gt; subchannels =
        new HashMap&lt;&gt;();
static final Attributes.Key&lt;Ref&lt;ConnectivityStateInfo&gt;&gt; STATE_INFO =
        Attributes.Key.create(&quot;state-info&quot;);

public RandomLoadBalancer(LoadBalancer.Helper helper) {
    this.helper = helper;
}
@Override
public void handleResolvedAddresses(ResolvedAddresses resolvedAddresses) {
    List&lt;EquivalentAddressGroup&gt; servers = resolvedAddresses.getAddresses();
    for(EquivalentAddressGroup server : servers){
        List&lt;EquivalentAddressGroup&gt; serverSingletonListt = Collections.singletonList(server);
        Subchannel exists = subchannels.getOrDefault(server, null);
        if(null != exists){
            exists.updateAddresses(serverSingletonListt);
            continue;
        }
        Attributes.Builder subchannelAttrs = Attributes.newBuilder()
                .set(STATE_INFO,
                        new Ref&lt;&gt;(ConnectivityStateInfo.forNonError(IDLE)));
        final Subchannel subchannel = helper.createSubchannel(CreateSubchannelArgs.newBuilder()
                        .setAddresses(serverSingletonListt)
                        .setAttributes(subchannelAttrs.build())
                        .build());
        subchannels.put(server, subchannel);
        subchannel.start(new SubchannelStateListener() {
            @Override
            public void onSubchannelState(ConnectivityStateInfo state) {
                for(Map.Entry&lt;EquivalentAddressGroup, Subchannel&gt; entry : subchannels.entrySet()){
                    if(subchannel == entry.getValue()){
                        if (state.getState() == SHUTDOWN) {
                            subchannels.remove(entry.getKey());
                        }
                        if (state.getState() == IDLE) {
                            subchannel.requestConnection();
                        }
                        subchannel.getAttributes().get(STATE_INFO).value = state;
                        updateBalancingState();
                        return;
                    }
                }
            }
        });
        subchannel.requestConnection();
    }
    updateBalancingState();
}
@Override
public void handleNameResolutionError(Status error) {
    shutdown();
    helper.updateBalancingState(TRANSIENT_FAILURE, new SubchannelPicker() {
        @Override
        public PickResult pickSubchannel(PickSubchannelArgs args) {
            return PickResult.withError(error);
        }
    });
}

private  void updateBalancingState(){
    boolean ready = true;
    for(Subchannel subchannel : this.subchannels.values()){
        if(subchannel.getAttributes().get(STATE_INFO).value.getState() != READY){
            helper.updateBalancingState(CONNECTING, new RandomSubchannelPick(subchannels.values()));
            return;
        }
    }
    helper.updateBalancingState(ConnectivityState.READY, new RandomSubchannelPick(subchannels.values()));
}

@Override
public void shutdown() {
    for(Iterator&lt;Map.Entry&lt;EquivalentAddressGroup, Subchannel&gt;&gt; itr = subchannels.entrySet().iterator(); itr.hasNext();){
        Map.Entry&lt;EquivalentAddressGroup, Subchannel&gt; e = itr.next();
        e.getValue().shutdown();
        itr.remove();
    }

}

class RandomSubchannelPick extends SubchannelPicker{
    Subchannel[] subchannels;
    Random random = new Random(System.currentTimeMillis());

    public RandomSubchannelPick(Collection&lt;Subchannel&gt; subchannels) {
        this.subchannels = subchannels.stream().toArray(Subchannel[]::new);
    }

    @Override
    public PickResult pickSubchannel(PickSubchannelArgs args) {
        int idx = random.nextInt(subchannels.length);
        return PickResult.withSubchannel(subchannels[idx]);
    }
}

public static class Provider extends LoadBalancerProvider{

    @Override
    public boolean isAvailable() {
        return true;
    }

    @Override
    public int getPriority() {
        return 100;
    }

    @Override
    public String getPolicyName() {
        return &quot;random&quot;;
    }

    @Override
    public LoadBalancer newLoadBalancer(LoadBalancer.Helper helper) {
        return new RandomLoadBalancer(helper);
    }
}

static final class Ref&lt;T&gt; {
    T value;

    Ref(T value) {
        this.value = value;
    }
}</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 服务端初始化</span><br><span class="line"></span><br><span class="line">服务端需要把自己的服务地址注册到zookeeper。</span><br></pre></td></tr></table></figure>

<p>private final int port;<br>private final Server server;<br>private String registryPath;<br>private String address;<br>CuratorFramework curator = CuratorFrameworkFactory.builder()<br>        .connectString(“127.0.0.1:2181”)<br>        .retryPolicy(new ExponentialBackoffRetry(1000, 5))<br>        .connectionTimeoutMs(1000)<br>        .sessionTimeoutMs(60000)<br>        .build();;</p>
<p>public GreetingServer(int port, String registryPath) throws IOException {<br>    this.port = port;<br>    server = ServerBuilder.forPort(port).addService(new GreetingService())<br>            .build();<br>    this.registryPath = registryPath;<br>    this.address =  “localhost:” + port;    //本机网卡不能正确显示地址，直接写死localhost<br>}</p>
<p>/**</p>
<ul>
<li><p>Start server.</p>
</li>
<li><p>/<br>public void start() throws Exception {<br>  this.curator.start();<br>  server.start();;<br>  this.curator.create()</p>
<pre><code>.creatingParentContainersIfNeeded()
.withMode(CreateMode.EPHEMERAL)
.forPath(registryPath + &quot;/&quot; + address, (&quot;http://&quot; + address).getBytes());</code></pre><p>  System.out.println(“Server started, listening on “ + address);<br>  Runtime.getRuntime().addShutdownHook(new Thread() {</p>
<pre><code>@Override
public void run() {
    GreetingServer.this.stop();
}</code></pre><p>  });<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">### 客户端初始化</span><br><span class="line"></span><br><span class="line">客户端需要注册自定义的NameResolverFactory和LoadBalancer。</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>public GreetingClient(String host, int port, String path) {<br>    String target = “zookeeper://“ + host + “:” + port + path;<br>    CuratorNameResolver.Factory factory = new CuratorNameResolver.Factory();</p>
<pre><code>LoadBalancerRegistry.getDefaultRegistry().register(new RandomLoadBalancer.Provider());
ManagedChannelBuilder&lt;?&gt; channelBuilder = ManagedChannelBuilder
        .forTarget(target)
        .nameResolverFactory(factory)
        .defaultLoadBalancingPolicy(&quot;random&quot;)
        .usePlaintext();
channel = channelBuilder.build();
blockingStub = GreetingGrpc.newBlockingStub(channel);</code></pre><p>}</p>
<pre><code>
# 参考资料

+ [示例代码](https://github.com/LiuMenghan/grpc-example)
+ [grpc-java源码地址](https://github.com/grpc/grpc-java)
+ [gRPC传输格式说明](https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md)



</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://liumenghan.github.io/2019/10/07/grpc-in-depth/" data-id="ck1gbzaid0000ggpvotx2he65" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/10/07/grpc-in-depth/">gRPC客户端详解</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>